var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Basic-Data-Structures","page":"API","title":"Basic Data Structures","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Position\nDirection\nLocation","category":"page"},{"location":"api/#KM3io.Position","page":"API","title":"KM3io.Position","text":"struct Position{T} <: StaticArraysCore.FieldVector{3, T}\n\nA vector to represent a position in 3D.\n\nFields\n\nx::Any\ny::Any\nz::Any\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Direction","page":"API","title":"KM3io.Direction","text":"struct Direction{T<:AbstractFloat} <: StaticArraysCore.FieldVector{3, T<:AbstractFloat}\n\nA vector to represent a direction in 3D.\n\nFields\n\nx::AbstractFloat\ny::AbstractFloat\nz::AbstractFloat\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Location","page":"API","title":"KM3io.Location","text":"struct Location\n\nA module's location in the detector where string represents the detection unit identifier and floor counts from 0 from the bottom to top. Base modules are sitting on floor 0 and optical modules on floor 1 and higher.\n\nFields\n\nstring::Int32\nfloor::Int8\n\n\n\n\n\n","category":"type"},{"location":"api/#Offline-Format","page":"API","title":"Offline Format","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Evt\nCalibratedHit\nCalibratedMCHit\nTrk\nMCTrk","category":"page"},{"location":"api/#KM3io.Evt","page":"API","title":"KM3io.Evt","text":"struct Evt\n\nAn offline event.\n\nFields\n\nid::Int64\ndet_id::Int64\nmc_id::Int64\nrun_id::Int64\nmc_run_id::Int64\nframe_index::Int64\ntrigger_mask::UInt64\ntrigger_counter::UInt64\noverlays::UInt64\nt::UTCTime\nhits::Vector{CalibratedHit}\ntrks::Vector{Trk}\nw::Vector{Float64}\nw2list::Vector{Float64}\nw3list::Vector{Float64}\nmc_event_time::UTCTime\nmc_t::Float64\nmc_hits::Vector{CalibratedMCHit}\nmc_trks::Vector{MCTrk}\nindex::Int64\nflags::Int64\nusr::Dict{String, Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.CalibratedHit","page":"API","title":"KM3io.CalibratedHit","text":"struct CalibratedHit <: AbstractCalibratedHit\n\nA calibrated hit of the offline dataformat. Caveat: the position, direction and t fields might still be 0 due to the design philosophy of the offline format (one class for all).\n\nFields\n\ndom_id::Int32\nchannel_id::UInt32\ntdc::UInt32\ntot::UInt32\ntrigger_mask::UInt64\nt::Float64\npos::Position{Float64}\ndir::Direction{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.CalibratedMCHit","page":"API","title":"KM3io.CalibratedMCHit","text":"struct CalibratedMCHit\n\nA calibrated MC hit of the offline dataformat. Caveat: the position and direction fields might still be 0 due to the design philosophy of the offline format (one class for all).\n\nFields\n\npmt_id::Int32\nt::Float64\na::Float64\ntype::Int32\norigin::Int32\npos::Position{Float64}\ndir::Direction{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Trk","page":"API","title":"KM3io.Trk","text":"struct Trk\n\nRepresents a reconstructed \"track\", which can be e.g. a muon track but also a shower.\n\nFields\n\nid::Int64\npos::Position{Float64}\ndir::Direction{Float64}\nt::Float64\nE::Float64\nlen::Float64\nlik::Float64\nrec_type::Int32\nrec_stages::Vector{Int32}\nfitinf::Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.MCTrk","page":"API","title":"KM3io.MCTrk","text":"struct MCTrk\n\nA simulated (Monte Carlo, hence \"MC\") track (or shower).\n\nFields\n\nid::Int64\npos::Position{Float64}\ndir::Direction{Float64}\nt::Float64\nE::Float64\nlen::Float64\ntype::Int32\nstatus::Int32\nmother_id::Int32\ncounter::Int32\n\n\n\n\n\n","category":"type"},{"location":"api/#Online-Format","page":"API","title":"Online Format","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DAQEvent\nEventHeader\nSnapshotHit\nTriggeredHit\nUTCTime\nUTCExtended\nSummaryslice\nSummarysliceHeader\nSummaryFrame","category":"page"},{"location":"api/#KM3io.DAQEvent","page":"API","title":"KM3io.DAQEvent","text":"struct DAQEvent\n\nA (triggered) event holding snapshot hits and triggered hits. The triggered hits are a subset of the snapshot hits.\n\nFields\n\nheader::EventHeader\nsnapshot_hits::Vector{SnapshotHit}\ntriggered_hits::Vector{TriggeredHit}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.EventHeader","page":"API","title":"KM3io.EventHeader","text":"struct EventHeader\n\nThe header of an event.\n\nFields\n\ndetector_id::Int32\nrun::Int32\nframe_index::Int32\nt::UTCExtended\ntrigger_counter::UInt64\ntrigger_mask::UInt64\noverlays::UInt32\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.SnapshotHit","page":"API","title":"KM3io.SnapshotHit","text":"struct SnapshotHit <: KM3io.AbstractDAQHit\n\nA snapshot hit.\n\nFields\n\ndom_id::UInt32\nchannel_id::UInt8\nt::Int32\ntot::UInt8\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.TriggeredHit","page":"API","title":"KM3io.TriggeredHit","text":"struct TriggeredHit <: KM3io.AbstractDAQHit\n\nA hit which was triggered.\n\nFields\n\ndom_id::Int32\nchannel_id::UInt8\nt::Int32\ntot::UInt8\ntrigger_mask::UInt64\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.UTCTime","page":"API","title":"KM3io.UTCTime","text":"struct UTCTime\n\nA basic time structure with seconds and nanoseconds. The seconds are counting from the start of the epoch, just like the UNIX time.\n\nFields\n\ns::UInt64\nns::UInt64\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.UTCExtended","page":"API","title":"KM3io.UTCExtended","text":"struct UTCExtended\n\nAn extended time structure which contains the White Rabbit time synchronisation status. wr_status == 0 means that the synchronisation is OK.\n\nFields\n\ns::UInt32\nns::UInt32\nwr_status::Int64\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Summaryslice","page":"API","title":"KM3io.Summaryslice","text":"struct Summaryslice\n\nA summaryslice is a condensed timeslice with the header information of the corresponding timeslice and a summary frame for each optical module. The hit information of the original timeslice is reduced so that for each PMT a single byte is used to encode the hit rate.\n\nFields\n\nheader::SummarysliceHeader\nframes::Vector{SummaryFrame}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.SummarysliceHeader","page":"API","title":"KM3io.SummarysliceHeader","text":"struct SummarysliceHeader\n\nThe header of a summaryslice.\n\nFields\n\ndetector_id::Int32\nrun::Int32\nframe_index::Int32\nt::UTCExtended\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.SummaryFrame","page":"API","title":"KM3io.SummaryFrame","text":"struct SummaryFrame\n\nA SummaryFrame contains reduced timeslice data from an optical module.\n\nThe PMT rates are encoded as single bytes and can be converted to real hit rates using the rates(s::SummaryFrame) function.\n\nFields\n\ndom_id::Int32\ndaq::UInt32\nstatus::UInt32\nfifo::UInt32\nstatus3::UInt32\nstatus4::UInt32\nrates::Vector{UInt8}\n\n\n\n\n\n","category":"type"},{"location":"api/#HDF5","page":"API","title":"HDF5","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"H5File\nH5CompoundDataset\naddmeta\ncreate_dataset\nflush","category":"page"},{"location":"api/#KM3io.H5File","page":"API","title":"KM3io.H5File","text":"struct H5File\n\nA wrapper for an HDF5 file used in KM3NeT.\n\nFields\n\n_h5f::HDF5.File\n_datasets::Dict{String, H5CompoundDataset}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.H5CompoundDataset","page":"API","title":"KM3io.H5CompoundDataset","text":"struct H5CompoundDataset{T}\n\nA flat HDF5 compound dataset which is essentially a vector of structs. It has a cache which is filled when elements are pushed to it. The cache is automatically written to the target HDF5 path when full.\n\nFields\n\ndset::HDF5.Dataset\ncache::KM3io.H5CompoundDatasetCache\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.addmeta","page":"API","title":"KM3io.addmeta","text":"addmeta(\n    dset::Union{HDF5.Dataset, HDF5.Datatype, HDF5.File, HDF5.Group},\n    object\n)\n\n\nAttaches key-value-pair meta entries to an HDF5 instance for each field of the given object.\n\n\n\n\n\n","category":"function"},{"location":"api/#HDF5.create_dataset","page":"API","title":"HDF5.create_dataset","text":"create_dataset(\n    f::H5File,\n    path::AbstractString,\n    ::Type{T};\n    cache_size\n) -> H5CompoundDataset\n\n\nCreates a one-dimensional compound dataset H5CompoundDataset of a given type which can be extended one-by-one. The cache is used to accumulate data and reduce the number of dataset extensions. Each time the cache is full, the HDF5 dataset will be extended, the buffer written and cleared.\n\nTo force the writing, use flush\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.flush","page":"API","title":"Base.flush","text":"flush(d::H5CompoundDataset) -> Vector\n\n\nForces the cache to be written to the HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hardware","page":"API","title":"Hardware","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"PMT\nDetectorModule\nDetector\nwrite(::AbstractString, ::Detector)\nwrite(::IO, ::Detector)\nHydrophone\nread(::AbstractString, ::Type{Hydrophone})\nTripod\nread(::AbstractString, ::Type{Tripod})\nwrite(::AbstractString, ::Vector{Tripod})\npiezoenabled\nhydrophoneenabled\ncenter","category":"page"},{"location":"api/#KM3io.PMT","page":"API","title":"KM3io.PMT","text":"struct PMT\n\nThe photomultiplier tube of an optical module. The id stands for the DAQ channel ID.\n\nA non-zero status means the PMT is \"not OK\". Individual bits can be read out to identify the problem (see definitions/pmt_status.jl for the bit positions and check them using the nthbitset() function).\n\nFields\n\nid::Int32\npos::Position{Float64}\ndir::Direction{Float64}\nt₀::Float64\nstatus::Union{Missing, Int32}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.DetectorModule","page":"API","title":"KM3io.DetectorModule","text":"struct DetectorModule\n\nEither a base module or an optical module. A non-zero status means the module is \"not OK\". Individual bits can be read out to identify the problem (see definitions/module_status.jl for the bit positions and check them using the nthbitset() function).\n\nFields\n\nid::Int32\npos::Position{Float64}\nlocation::Location\nn_pmts::Int8\npmts::Vector{PMT}\nq::Union{Missing, Quaternion{Float64}}\nstatus::Int32\nt₀::Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Detector","page":"API","title":"KM3io.Detector","text":"struct Detector\n\nA KM3NeT detector.\n\nFields\n\nversion::Int8\nid::Int32\nvalidity::Union{Missing, KM3io.DateRange}\npos::Union{Missing, UTMPosition{Float64}}\nutm_ref_grid::Union{Missing, String}\nn_modules::Int32\nmodules::Dict{Int32, DetectorModule}\nlocations::Dict{Tuple{Int64, Int64}, DetectorModule}\nstrings::Vector{Int64}\ncomments::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.write-Tuple{AbstractString, Detector}","page":"API","title":"Base.write","text":"write(filename::AbstractString, d::Detector; version)\n\n\nWrites the detector definition to a file, according to the DETX format specification. The version parameter can be a version number or :same, which is the default value and writes the same version as the provided detector has.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{IO, Detector}","page":"API","title":"Base.write","text":"write(io::IO, d::Detector; version)\n\n\nfunction write(io::IO, d::Detector; version=:same)\n\nWrites the detector to a DETX formatted file. The target version can be specified via the version keyword. Note that if converting to higher versions, missing parameters will be filled with reasonable default values. In case of downgrading, information will be lost.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.Hydrophone","page":"API","title":"KM3io.Hydrophone","text":"struct Hydrophone\n\nA hydrophone, typically installed in the base module of a KM3NeT detector's string.\n\nFields\n\nlocation::Location\npos::Position{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.read-Tuple{AbstractString, Type{Hydrophone}}","page":"API","title":"Base.read","text":"read(\n    filename::AbstractString,\n    T::Type{Hydrophone}\n) -> Vector{Hydrophone}\n\n\nfunction read(filename::AbstractString, T::Type{Hydrophone})\n\nReads a vector of Hydrophones from an ASCII file.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.Tripod","page":"API","title":"KM3io.Tripod","text":"struct Tripod\n\nA tripod installed on the seabed which sends acoustic signals to modules.\n\nFields\n\nid::Int8\npos::Position{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.read-Tuple{AbstractString, Type{Tripod}}","page":"API","title":"Base.read","text":"read(\n    filename::AbstractString,\n    T::Type{Tripod}\n) -> Vector{Tripod}\n\n\nfunction read(filename:AbstractString, T::Type{Tripod})\n\nReads a vector of Tripods from an ASCII file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{AbstractString, Vector{Tripod}}","page":"API","title":"Base.write","text":"write(filename::AbstractString, tripods::Vector{Tripod})\n\n\nfunction write(filename::AbstractString, tripods::Dict{Int8, Tripod})\n\nWrites the position of tripods out into an ASCII file.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.piezoenabled","page":"API","title":"KM3io.piezoenabled","text":"piezoenabled(m::DetectorModule) -> Bool\n\n\nfunction piezoenabled(m::DetectorModule)\n\nReturn true if the piezo is enabled, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.hydrophoneenabled","page":"API","title":"KM3io.hydrophoneenabled","text":"hydrophoneenabled(m::DetectorModule) -> Bool\n\n\nfunction hydrophonenabled(m::DetectorModule)\n\nReturn true if the hydrophone is enabled, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.center","page":"API","title":"KM3io.center","text":"center(m::DetectorModule) -> Position{Float64}\n\n\nCalculate the centre of a module by fitting the crossing point of the PMT axes.\n\n\n\n\n\ncenter(d::Detector) -> Position{Float64}\n\n\nCalculate the center of the detector based on the location of the optical modules.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optical-Data","page":"API","title":"Optical Data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Acoustics","page":"API","title":"Acoustics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Waveform\nread(filename::AbstractString, T::Type{Waveform})\nAcousticSignal\nAcousticsTriggerParameter\nread(filename::AbstractString, T::Type{AcousticsTriggerParameter})","category":"page"},{"location":"api/#KM3io.Waveform","page":"API","title":"KM3io.Waveform","text":"struct Waveform\n\nWaveform translates Emitter ID to Tripod ID.\n\nFields\n\nids::Dict{Int8, Int8}\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.read-Tuple{AbstractString, Type{Waveform}}","page":"API","title":"Base.read","text":"read(\n    filename::AbstractString,\n    T::Type{Waveform}\n) -> Waveform\n\n\nfunction read(filename::AbstractString, T::Type{Waveform})\n\nReads the waveform ASCII file.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.AcousticSignal","page":"API","title":"KM3io.AcousticSignal","text":"struct AcousticSignal\n\nAcousticSignal is a custom type with four fields to store all the information inside the raw acoustic binary files.\n\ndom_id::Int32 ID of the module\nutc_seconds:: UInt32 storing the first 4 Bytes and is a UNIX time stamp\nns_cycles:: UInt32 storing the second 4 Bytes\nsamples:: UInt32 storing the third 4 Bytes, corresponding to the number of data points accuired during the measring window\npcm:: Vector of Float32 of length frame_length, storing all other 4 Byte blocks. Each entry is a data point of the acoustic signal.\n\nFields\n\ndom_id::Int32\nutc_seconds::UInt32\nns_cycles::UInt32\nsamples::UInt32\npcm::Vector{Float32}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.AcousticsTriggerParameter","page":"API","title":"KM3io.AcousticsTriggerParameter","text":"struct AcousticsTriggerParameter\n\nCertain parameters which define an acoustic event.\n\nFields\n\nq::Float64\ntmax::Float64\nnmin::Int32\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.read-Tuple{AbstractString, Type{AcousticsTriggerParameter}}","page":"API","title":"Base.read","text":"read(\n    filename::AbstractString,\n    T::Type{AcousticsTriggerParameter}\n) -> AcousticsTriggerParameter\n\n\nfunction read(filename::AbstractString, T::Type{AcousticsTriggerParameter})\n\nReads the 'acousticstriggerparameters.txt' file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Calibration","page":"API","title":"Calibration","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"calibrate\nfloordist\nslew","category":"page"},{"location":"api/#KM3io.calibrate","page":"API","title":"KM3io.calibrate","text":"calibrate(det::Detector, hits) -> Vector{XCalibratedHit}\n\n\nApply geometry and time calibration to given hits.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.floordist","page":"API","title":"KM3io.floordist","text":"floordist(det::Detector) -> Float64\n\n\nCalculates the average floor distance between neighboured modules.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.slew","page":"API","title":"KM3io.slew","text":"slew(tot::Integer) -> Any\n\n\nReturn the time slewing for a ToT.\n\n\n\n\n\n","category":"function"},{"location":"api/#Physics","page":"API","title":"Physics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"azimuth\nzenith\nphi\ntheta\ncherenkov\nCherenkovPhoton\nK40Rates","category":"page"},{"location":"api/#KM3io.azimuth","page":"API","title":"KM3io.azimuth","text":"azimuth(d::Direction) -> Any\n\n\nCalculates the azimuth from a given Direction according to KM3NeT conventions.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.zenith","page":"API","title":"KM3io.zenith","text":"zenith(d::Direction) -> Any\n\n\nCalculates the zenith from a given Direction according to KM3NeT conventions.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.phi","page":"API","title":"KM3io.phi","text":"phi(d::Direction) -> Any\n\n\nCalculate the phi angle for a given direction\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.theta","page":"API","title":"KM3io.theta","text":"theta(d::Direction) -> Any\n\n\nCalculate the theta angle for a given direction\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.cherenkov","page":"API","title":"KM3io.cherenkov","text":"cherenkov(\n    track,\n    hits::Array{T<:AbstractCalibratedHit, 1}\n) -> Any\n\n\nCalculates the parameters of cherenkov photons emitted from a track and hitting the PMTs represented as (calibrated) hits. The returned cherenkov photons hold information about the closest distance to track, the time residual, arrival time, impact angle, photon travel distance, track travel distance and photon travel direction. See CherenkovPhoton for more information.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.CherenkovPhoton","page":"API","title":"KM3io.CherenkovPhoton","text":"struct CherenkovPhoton\n\nA Cherenkov photon with parameters calculated from its inducing track. See cherenkov() for more information.\n\nFields\n\nd_closest::Float64\nd_photon::Float64\nd_track::Float64\nt::Float64\nΔt::Float64\nimpact_angle::Float64\ndir::Direction{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.K40Rates","page":"API","title":"KM3io.K40Rates","text":"struct K40Rates\n\nK40 rates with L0 and higher level rates (with increasing multiplicities).\n\nFields\n\nL0::Float64\nL1::Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#Trigger","page":"API","title":"Trigger","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"triggered\nis3dmuon\nis3dshower\nismxshower\nisnb","category":"page"},{"location":"api/#KM3io.triggered","page":"API","title":"KM3io.triggered","text":"triggered(e) -> Vector\n\n\nReturn true if the passed object (hit, event, ...) was triggered by any trigger algorithm.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.is3dmuon","page":"API","title":"KM3io.is3dmuon","text":"is3dmuon(e::DAQEvent) -> Bool\n\n\nis3dmuon(e)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:12.\n\nReturn true the 3D Muon trigger bit is set.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.is3dshower","page":"API","title":"KM3io.is3dshower","text":"is3dshower(e::DAQEvent) -> Bool\n\n\nis3dshower(e)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:20.\n\nReturn true if the 3D Shower trigger bit is set.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.ismxshower","page":"API","title":"KM3io.ismxshower","text":"ismxshower(x) -> Bool\n\n\nismxshower(x)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:28.\n\nismxshower(e)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:29.\n\nReturn true if the MX Shower trigger bit is set.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.isnb","page":"API","title":"KM3io.isnb","text":"isnb(x) -> Bool\n\n\nisnb(x)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:36.\n\nisnb(e)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:37.\n\nReturn true if the NanoBeacon trigger bit is set.\n\n\n\n\n\n","category":"function"},{"location":"api/#ControlHost","page":"API","title":"ControlHost","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CHClient","category":"page"},{"location":"api/#KM3io.CHClient","page":"API","title":"KM3io.CHClient","text":"struct CHClient{T}\n\nA ControlHost client which can communicate with a Ligier dispatcher to receive messages for all the subscribed tags.\n\nTo connect to a Ligier which is receiving triggered DAQ events e.g. in the KM3NeT monitoring system or in a test setup consisting of a JLigier dispatcher and a JRegurgitate instance which is redispatching DAQ events (JDAQEvent) from a ROOT file in online format to the JLigier, a CHClient can be created to subscribe the event messages with\n\njulia> using KM3io\n\njulia> c = CHClient{DAQEvent}(ip\"127.0.0.1\", 5553)\n\njulia> for event in c\n           @show event\n       end\ne = KM3io.DAQEvent with 127 snapshot and 6 triggered hits\ne = KM3io.DAQEvent with 147 snapshot and 6 triggered hits\ne = KM3io.DAQEvent with 154 snapshot and 8 triggered hits\ne = KM3io.DAQEvent with 152 snapshot and 6 triggered hits\n...\n...\n...\n\nFields\n\nip::Sockets.IPv4\nport::UInt16\ntags::Vector{CHTag}\nsocket::Sockets.TCPSocket\n\n\n\n\n\n","category":"type"},{"location":"api/#Tools","page":"API","title":"Tools","text":"","category":"section"},{"location":"api/#General-tools","page":"API","title":"General tools","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"categorize\nnthbitset\nmost_frequent","category":"page"},{"location":"api/#KM3io.categorize","page":"API","title":"KM3io.categorize","text":"categorize(field::Symbol, elements::Vector) -> Dict\n\n\nCategorise the struct elements of a vector by a given field into a dictionary of T.field => Vector{T}.\n\nExamples\n\njulia> using KM3io\n\njulia> struct PMT  # just an ad-hoc PMT struct for demonstration purposes\n         dom_id\n         time\n       end\n\njulia> pmts = [PMT(2, 10.4), PMT(4, 23.5), PMT(2, 42.0)];\n\njulia> categorize(:dom_id, pmts)\nDict{Any, Vector{PMT}} with 2 entries:\n  4 => [PMT(4, 23.5)]\n  2 => [PMT(2, 10.4), PMT(2, 42.0)]\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.nthbitset","page":"API","title":"KM3io.nthbitset","text":"nthbitset(n, a) -> Any\n\n\nReturn true if the n-th bit of a is set, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.most_frequent","page":"API","title":"KM3io.most_frequent","text":"most_frequent(iterable) -> Any\n\n\nReturn the most frequent value of a given iterable.\n\n\n\n\n\nmost_frequent(f::Function, iterable; rettype) -> Int64\n\n\nReturn the most frequent value of a given iterable based on the return value of a function f which returns (hashable) values of rettype.\n\n\n\n\n\n","category":"function"},{"location":"api/#DAQ","page":"API","title":"DAQ","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"pmtrate\npmtrates\nhrvstatus\nfifostatus\ntdcstatus\nwrstatus\nhasudptrailer\ncount_active_channels\ncount_fifostatus\ncount_hrvstatus\nstatus\nnumber_of_udp_packets_received\nmaximal_udp_sequence_number","category":"page"},{"location":"api/#KM3io.pmtrate","page":"API","title":"KM3io.pmtrate","text":"pmtrate(r::UInt8) -> Float64\n\n\nCalculate the PMT hit rate from the raw byte stored in a summary frame.\n\nThe rate of each PMT is encoded in a single byte to reduce the size of the summary frame, therefore only 256 values are possible which are mapped to an exponential function. The values are precalculated by the _getrate() function for the best performance.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.pmtrates","page":"API","title":"KM3io.pmtrates","text":"pmtrates(s::SummaryFrame) -> Vector{Float64}\n\n\nReturn the actual rates (in Hz) for each PMT in a summary frame.\n\n\n\n\n\npmtrates(s::Summaryslice) -> Dict{Int32, Vector{Float64}}\n\n\nReturn a dictionary of DOM IDs as keys and PMT rates [Hz] as values (Vector{Float64}).\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.hrvstatus","page":"API","title":"KM3io.hrvstatus","text":"hrvstatus(f::SummaryFrame, tdc) -> Any\n\n\nReturn true if the TDC is in high rate veto.\n\n\n\n\n\nhrvstatus(f::SummaryFrame) -> Bool\n\n\nReturn true if any of the TDCs is in high rate veto.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.fifostatus","page":"API","title":"KM3io.fifostatus","text":"fifostatus(f::SummaryFrame, tdc) -> Any\n\n\nReturn true if the TDC has FIFO almost full.\n\n\n\n\n\nfifostatus(f::SummaryFrame) -> Bool\n\n\nReturn true if any of the TDCs is in high rate veto.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.tdcstatus","page":"API","title":"KM3io.tdcstatus","text":"tdcstatus(f::SummaryFrame) -> Bool\n\n\nReturn true if TDC status is OK.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.wrstatus","page":"API","title":"KM3io.wrstatus","text":"wrstatus(f::SummaryFrame) -> Bool\n\n\nReturn true if White Rabbit status is OK.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.hasudptrailer","page":"API","title":"KM3io.hasudptrailer","text":"hasudptrailer(f::SummaryFrame) -> Bool\n\n\nReturn true if the UDP trailer is present.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.count_active_channels","page":"API","title":"KM3io.count_active_channels","text":"count_active_channels(f::SummaryFrame) -> Int64\n\n\nNumber of TDCs without high rate veto or FIFO almost full.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.count_fifostatus","page":"API","title":"KM3io.count_fifostatus","text":"count_fifostatus(f::SummaryFrame) -> Int64\n\n\nNumber of TDCs with FIFO almost full.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.count_hrvstatus","page":"API","title":"KM3io.count_hrvstatus","text":"count_hrvstatus(f::SummaryFrame) -> Int64\n\n\nNumber of TDCs with high rate veto.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.status","page":"API","title":"KM3io.status","text":"status(f::SummaryFrame) -> Bool\n\n\nReturn true if TDC and White Rabbit status are OK.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.number_of_udp_packets_received","page":"API","title":"KM3io.number_of_udp_packets_received","text":"number_of_udp_packets_received(f::SummaryFrame) -> Int32\n\n\nNumber of received UDP packets (excluding the trailer).\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.maximal_udp_sequence_number","page":"API","title":"KM3io.maximal_udp_sequence_number","text":"maximal_udp_sequence_number(f::SummaryFrame) -> Int32\n\n\nMaximal sequence number of all received UDP packets.\n\n\n\n\n\n","category":"function"},{"location":"api/#Reconstruction","page":"API","title":"Reconstruction","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"besttrack\nbestjppmuon\nbestjppshower\nbestaashower\nRecStageRange\nhashistory","category":"page"},{"location":"api/#KM3io.besttrack","page":"API","title":"KM3io.besttrack","text":"besttrack(\n    e::Evt,\n    rec_type::Integer,\n    rsr::RecStageRange\n) -> Union{Nothing, Trk}\n\n\nReturn the best reconstructed track for a given reconstruction type and reconstruction stage range. If no track could be found, nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.bestjppmuon","page":"API","title":"KM3io.bestjppmuon","text":"bestjppmuon(e::Evt) -> Union{Nothing, Trk}\n\n\nReturns the best reconstructed JMuon track of an event or nothing if there are none.\n\n\n\n\n\nbestjppmuon(trks::Vector{Trk}) -> Union{Nothing, Trk}\n\n\nReturns the best reconstructed JMuon track or nothing if there are none.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.bestjppshower","page":"API","title":"KM3io.bestjppshower","text":"bestjppshower(e::Evt) -> Union{Nothing, Trk}\n\n\nReturns the best reconstructed JShower \"track\" of an event or nothing if there are none.\n\n\n\n\n\nbestjppshower(trks::Vector{Trk}) -> Union{Nothing, Trk}\n\n\nReturns the best reconstructed JShower \"track\" or nothing if there are none.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.bestaashower","page":"API","title":"KM3io.bestaashower","text":"bestaashower(e::Evt) -> Union{Nothing, Trk}\n\n\nReturns the best reconstructed aashower \"track\" of an event or nothing if there are none.\n\n\n\n\n\nbestaashower(trks::Vector{Trk}) -> Union{Nothing, Trk}\n\n\nReturns the best reconstructed aashower \"track\" or nothing if there are none.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.RecStageRange","page":"API","title":"KM3io.RecStageRange","text":"struct RecStageRange{T<:Integer}\n\nThis struct is used to represent a range of reconstruction stages. These are well-defined integers (see KM3NeT Dataformat) for each reconstruction algorithm and are stored in a vector named rec_stages of each Trk.\n\njulia> using KM3io\n\njulia> rsr = RecStageRange(KM3io.RECONSTRUCTION.JMUONBEGIN, KM3io.RECONSTRUCTION.JMUONEND)\nRecStageRange{Int64}(0, 99)\n\njulia> KM3io.RECONSTRUCTION.JMUONSIMPLEX ∈ rsr\ntrue\n\njulia> KM3io.RECONSTRUCTION.AASHOWERFITPREFIT ∈ rsr\nfalse\n\njulia> 23 ∈ rsr\ntrue\n\njulia> 523 ∈ rsr\nfalse\n\nFields\n\nlower::Integer\nupper::Integer\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.hashistory","page":"API","title":"KM3io.hashistory","text":"hashistory(\n    t::Trk,\n    rec_type::Integer,\n    rsr::RecStageRange\n) -> Bool\n\n\nReturns true if a track with a given rec_type contains all the reconstruction stages in rsr::RecStageRange.\n\n\n\n\n\nhashistory(\n    t::Trk,\n    rec_type::Integer,\n    rec_stage::Integer\n) -> Union{Missing, Bool}\n\n\nReturns true if a track with a given rec_type contains the rec_stage.\n\n\n\n\n\n","category":"function"},{"location":"examples/cherenkov_times/#Cherenkov-times","page":"Cherenkov times","title":"Cherenkov times","text":"","category":"section"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"using PGFPlotsX\nsavefigs = (figname, obj) -> begin\n    pgfsave(figname * \".pdf\", obj)\n    run(`pdftocairo -svg -l  1 $(figname * \".pdf\") $(figname * \".svg\")`)\n    pgfsave(figname * \".tex\", obj);\n    return nothing\nend","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"In this example, we will pick the best reconstructed muon (from the Jpp muon reconstruction chain JMuon) in each event and calculate the Cherenkov hit time residuals for each triggered hit.","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"We open the a sample file from the KM3NeTTestData package:","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"using KM3io, KM3NeTTestData\n\nf = ROOTFile(datapath(\"offline\", \"mcv6.0.gsg_muon_highE-CC_50-500GeV.km3sim.jterbr00008357.jorcarec.aanet.905.root\"))","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"Each event holds a vector of reconstructed tracks (Vector{Trk}) behind the .trks field. This vector contains different stages of reconstruction results from a variety of reconstruction algorithms (JMuon, JShower, aashower etc.). KM3io.jl exports helper functions to pick the best reconstructed track for a given reconstruction algorithm. The logic is based on the reference implementation in KM3NeT DataFormat tools. The function bestjppmuon() can be used to select the best reconstructed JMuon for a given event:","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"evt = f.offline[1]\nbest_muon = bestjppmuon(evt)","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"We now use this track as a seed to calculate the Cherenkov photon (see CherenkovPhoton) parameters using cherenkov() for each hit triggered hit in the event. To select only triggered hits, we use the triggered() function together withe filter() which returns a new vector of triggered hits:","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"cherenkov(best_muon, filter(triggered, evt.hits))","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"To obtain more statistics, we iterate through all the events and calculate the Cherenkov time residuals for each set of hits based on the best reconstruction track. We fill the time residuals in a 1D histogram using the FHist package.","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"note: Note\nThis example uses PGFPlotsX which is a wrapper for the LaTeX library PGFPlots. Feel free to adapt the example to use your favourite plotting library.","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"using FHist\n\nΔts = Hist1D(;bins=-10:50)\n\nfor evt ∈ f.offline\n    m = bestjppmuon(evt)\n    cherenkov_photons = cherenkov(m, filter(triggered, evt.hits))\n    for cp ∈ cherenkov_photons\n        push!(Δts, cp.Δt)\n    end\nend\n\naxis = @pgf Axis(\n    {\n        ybar, const_plot, grid,\n        xlabel=raw\"\\Delta t / ns\",\n        ylabel=\"counts\",\n    },\n    PlotInc(Coordinates(bincenters(Δts), bincounts(Δts)), raw\"\\closedcycle\")\n)\naxis\nsavefigs(\"cherenkov\", ans) # hide","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"[.pdf], [generated .tex]","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"(Image: )","category":"page"},{"location":"manual/calibration/#Calibration","page":"Calibration","title":"Calibration","text":"","category":"section"},{"location":"manual/detector/#Detector-and-its-Components","page":"Detector and its Components","title":"Detector and its Components","text":"","category":"section"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"In this example, we will explore the components of a KM3NeT detector, which is represented by the Detector type in KM3io.jl. The detector description is stored in so-called DETX-files, named after its filename extension .detx). It's an ASCII-based file format and by the time of writing this example, v5 is the latest format version. There is a yet unofficial binary version of this format named DATX (with the filename extension datx), which is currently not supported, neither widely used in KM3NeT.","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"note: Note\nKM3io.jl offers conversions between the different DETX format versions. Typically, each major version brings a new set of parameters. Downgrading is therefore not lossless. When when upgrading from one version to another, the new parameters needs to be filled in. Some of these can be calculated from existing ones, like the module position, which was introduced in v4 and is equal to the crossing point of the PMT axes. Otherwise, these parameters are either set to meaningful default values or to missing.","category":"page"},{"location":"manual/detector/#Loading-a-DETX-File","page":"Detector and its Components","title":"Loading a DETX File","text":"","category":"section"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"The Detector type offers a constructor which takes a filepath to a DETX file. The KM3NeTTestData.jl offers a collection of detector sample files, so let's pick one of them:","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"using KM3io, KM3NeTTestData\n\ndet = Detector(datapath(\"detx\", \"detx_v5.detx\"))","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"A detector configuration (format version 5) has been loaded with 6 strings (sometimes also called detection unit or DU) holding a total 114 modules.","category":"page"},{"location":"manual/detector/#Accessing-Modules","page":"Detector and its Components","title":"Accessing Modules","text":"","category":"section"},{"location":"manual/detector/#Iterating-over-all-modules","page":"Detector and its Components","title":"Iterating over all modules","text":"","category":"section"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"There are multiple ways to access modules within a Detector. One of them is iterating over it, which yields DetectorModule instances in no specific order:","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"for m in det\n    println(m)\nend","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"warning: Warning\nmodule is a reserved keyword in Julia and mod is the \"modulo function\", so keep this in mind when chosing a variable name for a DetectorModule. Most of the time m is fine, or just be verbose with detector_module and use your editors tab-completion.","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"As we can see in the output, there are two types of modules: optical modules and base modules. The main difference between the two in the detector file context is that base modules do not contain PMTs and are always sitting on floor 0.","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"note: Note\nAlthough iterating over a Detector feels like iterating over a vector, accessing single elements via det[idx] will not work as such since it requires the idx to be a module ID. This design was chosen since the detector dataformat specification does not specify module ordering, so there is no such thing as the \"n-th module\". Accessing modules by their module ID however is the standard use case, see below.","category":"page"},{"location":"manual/detector/#Modules-via-\"module-ID\"","page":"Detector and its Components","title":"Modules via \"module ID\"","text":"","category":"section"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"Modules have a unique identification number called module ID (sometimes also called \"DOM ID\", where DOM stands for \"Digital Optical Module\") and we can use this ID to access individual modules within a Detector instance.","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"The .modules field is a dictionary which maps the modules to their module IDs:","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"det.modules","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"To access a module with a given module ID, one can either use this dictionary or index the Detector directly","category":"page"},{"location":"manual/detector/","page":"Detector and its Components","title":"Detector and its Components","text":"detector_module = det[808976933]","category":"page"},{"location":"manual/rootfiles/#ROOT-Files","page":"ROOT Files","title":"ROOT Files","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The two main types of ROOT files in KM3NeT are the online and offline files, however, both types can be mixed together as the data is stored in distinct ROOT trees. UnROOT has a single ROOTFile type to represent a KM3NeT ROOT file which can be used to access both the online and offline information. This section describes what kind of data is stored in each tree and how to access them.","category":"page"},{"location":"manual/rootfiles/#offline-dataformat","page":"ROOT Files","title":"Offline Dataformat","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The offline dataformat is used to store Monte Carlo (MC) simulations and reconstruction results. The OfflineTree type represents an actual offline file and it is essentially a vector of events (Vector{Evt}) with some fancy caching, lazy access and slicing magic. The offline tree is accessible via the .offline field of the ROOTFile type.","category":"page"},{"location":"manual/rootfiles/#MC-Header","page":"ROOT Files","title":"MC Header","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The MC header stores metadata related to the simulation chain. The individual entries can be accessed as properties, as shown below.","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"julia> using KM3io, KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"offline\", \"numucc.root\"))\nROOTFile{OnlineTree (0 events, 0 summaryslices), OfflineTree (10 events)}\n\njulia> f.offline\nOfflineTree (10 events)\n\njulia> f.offline.header\nMCHeader\n  DAQ => (livetime = 394,)\n  PDF => (i1 = 4, i2 = 58)\n  XSecFile => Any[]\n  can => (zmin = 0, zmax = 1027, r = 888.4)\n  can_user => [0.0, 1027.0, 888.4]\n  coord_origin => (x = 0, y = 0, z = 0)\n  cut_in => (Emin = 0, Emax = 0, cosTmin = 0, cosTmax = 0)\n  cut_nu => (Emin = 100, Emax = 1.0e8, cosTmin = -1, cosTmax = 1)\n  cut_primary => (Emin = 0, Emax = 0, cosTmin = 0, cosTmax = 0)\n  cut_seamuon => (Emin = 0, Emax = 0, cosTmin = 0, cosTmax = 0)\n  decay => [\"doesnt\", \"happen\"]\n  detector => NOT\n  drawing => Volume\n  end_event => Any[]\n  genhencut => (gDir = 2000, Emin = 0)\n  genvol => (zmin = 0, zmax = 1027, r = 888.4, volume = 2.649e9, numberOfEvents = 100000)\n  kcut => 2\n  livetime => (numberOfSeconds = 0, errorOfSeconds = 0)\n  model => (interaction = 1, muon = 2, scattering = 0, numberOfEnergyBins = 1, field_4 = 12)\n  muon_desc_file => Any[]\n  ngen => 100000.0\n  norma => (primaryFlux = 0, numberOfPrimaries = 0)\n  nuflux => Real[0, 3, 0, 0.5, 0.0, 1.0, 3.0]\n  physics => (program = \"GENHEN\", version = \"7.2-220514\", date = 181116, time = 1138)\n  seed => (program = \"GENHEN\", level = 3, iseed = 305765867, field_3 = 0, field_4 = 0)\n  simul => (program = \"JSirene\", version = 11012, date = \"11/17/18\", time = 7)\n  sourcemode => diffuse\n  spectrum => (alpha = -1.4,)\n  start_run => 1\n  target => isoscalar\n  usedetfile => false\n  xlat_user => 0.63297\n  xparam => OFF\n  zed_user => [0.0, 3450.0]\n\n\njulia> f.offline.header.genvol\n(zmin = 0, zmax = 1027, r = 888.4, volume = 2.649e9, numberOfEvents = 100000)\n\njulia> f.offline.header.genvol.volume\n2.649e9","category":"page"},{"location":"manual/rootfiles/#Event-data","page":"ROOT Files","title":"Event data","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The following REPL session shows how to open a file, access individual events or slices of events, loop through events and access e.g. the tracks which are stored in the events.","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"julia> using KM3io, KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"offline\", \"km3net_offline.root\"))\nROOTFile{OfflineTree (10 events)}\n\njulia> f.offline[5]\nKM3io.Evt (83 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n\njulia> f.offline[3:5]\n3-element Vector{KM3io.Evt}:\n KM3io.Evt (318 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n KM3io.Evt (157 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n KM3io.Evt (83 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n\njulia> event = f.offline[1]\nKM3io.Evt (176 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n\njulia> event.trks[1:4]\n4-element Vector{KM3io.Trk}:\n KM3io.Trk(1, [445.835395997812, ... , 294.6407542676734, 4000)\n KM3io.Trk(2, [445.835395997812, ... , 294.6407542676734, 4000)\n KM3io.Trk(3, [448.136188112227, ... , 294.6407542676734, 4000)\n KM3io.Trk(4, [448.258348900570, ... , 291.64653112688273, 4000)\n\njulia> for event in f.offline\n           @show event\n       end\nevent = KM3io.Evt (176 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (125 hits, 0 MC hits, 55 tracks, 0 MC tracks)\nevent = KM3io.Evt (318 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (157 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (83 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (60 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (71 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (84 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (255 hits, 0 MC hits, 54 tracks, 0 MC tracks)\nevent = KM3io.Evt (105 hits, 0 MC hits, 56 tracks, 0 MC tracks)","category":"page"},{"location":"manual/rootfiles/#online_dataformat","page":"ROOT Files","title":"Online Dataformat","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The online dataformat refers to the dataformat which is written by the data acquisition system (DAQ) of the KM3NeT detectors, more precisely, the ROOT files produced by the JDataFilter which is part of the Jpp framework. The very same format is used in run-by-run (RBR) Monte Carlo (MC) productions, which mimic the detector response and therefore produce similarly structured data. The online data can be accessed via the .online field of the ROOTFile type.","category":"page"},{"location":"manual/rootfiles/#Event-data-2","page":"ROOT Files","title":"Event data","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The events are accessible via ROOTFile(filename).online.events which supports indexing, slicing and iteration, just like the we have seen above, in case of the offline events. Notice however that the online format also contains other types of trees, that's why the explicit .events field is needed. Everything is lazily loaded so that the data is only occupying memory when it's actually accessed, similar to the offline access. In the examples below, we use KM3NeTTestdata to get access to small sample files.","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"julia> using KM3io, KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"online\", \"km3net_online.root\"))\nROOTFile{OnlineTree (3 events, 3 summaryslices), OfflineTree (0 events)}\n\njulia> event = f.online.events[1]\nKM3io.DAQEvent with 96 snapshot and 18 triggered hits\n\njulia> event.triggered_hits[4:8]\n5-element Vector{KM3io.TriggeredHit}:\n KM3io.TriggeredHit(808447186, 0x00, 30733214, 0x19, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x01, 30733214, 0x15, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x02, 30733215, 0x15, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x03, 30733214, 0x1c, 0x0000000000000016)\n KM3io.TriggeredHit(808451907, 0x07, 30733441, 0x1e, 0x0000000000000004)\n\njulia> for event ∈ f.online.events\n           @show event.header.frame_index length(event.snapshot_hits)\n       end\nevent.header.frame_index = 127\nlength(event.snapshot_hits) = 96\nevent.header.frame_index = 127\nlength(event.snapshot_hits) = 124\nevent.header.frame_index = 129\nlength(event.snapshot_hits) = 78","category":"page"},{"location":"manual/rootfiles/#Summaryslices-and-Summary-Frames","page":"ROOT Files","title":"Summaryslices and Summary Frames","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"Summaryslices are generated from timeslices (raw hit data) and are produced by the DataFilter. A slice contains the data of 100ms and is divided into so-called frames, each corresponding to the data of a single optical module. Due to the high amount of data, the storage of timeslices is usually reduced by a factor of 10-100 after the event triggering stage. However, summaryslices are covering the full data taking period. They however do not contain hit data but only the rates of the PMTs encoded into a single byte, which therefore is only capable to store 256 different values. The actual rate is calcuated by the helper functions pmtrate() and pmtrates() which take a SummaryFrame and optionally a PMT channel ID as arguments.","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The summaryslices are accessible using the .summaryslices attribute of the OnlineTree instance, which again is hidden behind the .online field of a ROOTFile:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"julia> using KM3io, KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"online\", \"km3net_online.root\"))\nROOTFile{OnlineTree (3 events, 3 summaryslices), OfflineTree (0 events)}\n\njulia> f.online.summaryslices\nKM3io.SummarysliceContainer with 3 summaryslices\n\njulia> for s ∈ f.online.summaryslices\n           @show s.header\n       end\ns.header = KM3io.SummarysliceHeader(44, 6633, 126, KM3io.UTCExtended(0x5dc6018c, 0x23c34600, false))\ns.header = KM3io.SummarysliceHeader(44, 6633, 127, KM3io.UTCExtended(0x5dc6018c, 0x29b92700, false))\ns.header = KM3io.SummarysliceHeader(44, 6633, 128, KM3io.UTCExtended(0x5dc6018c, 0x2faf0800, false))","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"Each summaryslice consists of multiple frames, one for every optical module which has sent data during the recording time of the corresponding timeslice.","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"note: Note\nDuring run transistions, the number of summaryframes in a summaryslice is fluctuating a lot until it eventually saturates, usually within a few seconds or minutes. Therefore, it is expected that the number of summaryframes (i.e. active DOMs) is low at the beginning of the file and stabilises after a few summaryslices.","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"To access the actual PMT rates and flags (e.g. for high-rate veto or FIFO status) of a summaryframe, several helper functions exist. Let's grab a summaryslice:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"using KM3io, KM3NeTTestData\n\nf = ROOTFile(datapath(\"online\", \"km3net_online.root\"))\n\ns = f.online.summaryslices[1]","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"and have a look at one of the frames, the 23rd of the first summaryslice:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"frame = s.frames[23]","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The White Rabbit status:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"wrstatus(frame)","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"Checking if any of the PMTs is in high rate veto:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"hrvstatus(frame)","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The number of PMTs in high rate veto:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"count_hrvstatus(frame)","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"Checking if any of the TDC FIFOs were almost full:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"fifostatus(frame)","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"Counting the number of TDCs which had FIFO almost full:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"count_fifostatus(frame)","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The rates of each individual PMT channel ordered by increasing channel ID:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"pmtrates(frame)","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"Individual PMT parameters can be accessed as well, by passing the summaryframe and the PMT ID (DAQ channel ID):","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"pmtrate(frame, 3)","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"Here is an example of a simple summary output:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"for pmt in 0:30\n    println(\"PMT $(pmt): HRV($(hrvstatus(frame, pmt))) FIFO($(fifostatus(frame, pmt)))\")\nend","category":"page"},{"location":"examples/hdf5/#HDF5","page":"HDF5","title":"HDF5","text":"","category":"section"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"Plain ASCII (CSV) files are often perfectly fine for small, tabular datasets but when dealing with larger amounts of data, HDF5 comes in handy with compression, metadata and hierachical datasets. KM3NeT uses HDF5 in many analysis chains, often to store intermediate or end results.","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"This example shows how to create an HDF5 file and write some vectors of structs into different datasets.","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"using KM3io\nusing Random\n\nRandom.seed!(23)  # to make things reproducible ;)\n\nf = H5File(\"foo.h5\", \"w\")","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"We now have an H5File instance which we can use to store datasets.","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"Let's say we have our custom data type (struct) like","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"struct Particle\n    x::Float32\n    y::Float32\n    E::Int64\nend","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"and we generate instances of Particle in a loop which we want to dump directly into an HDF5 file to the dataset stored at simulation/particles, meaning that simulation is the group name and particles the dataset name.","category":"page"},{"location":"examples/hdf5/#Creating-datasets","page":"HDF5","title":"Creating datasets","text":"","category":"section"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"First, we create our dataset with our type Particle. This is a so called H5CompoundDataset and resembles a dataset wich has a compound type (struct) associated with it:","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"dset = create_dataset(f, \"simulation/particles\", Particle)","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"We fill some random particles using the dummy loop:","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"for i in 1:1000\n    # creates some random particle\n    particle = Particle(rand(), rand(), rand(1:1000))\n    # we push to the dataset, just like if it was an Array\n    push!(dset, particle)\nend","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"note: Note\nTo avoid excessive I/O, KM3io uses a cache for each H5CompoundDataset. If you don't close the H5File properly, you might lose data which is still sitting in the cache. Therefore, always use close(f) to make sure that all the caches are dumped to the HDF5 file. The methods flush(d::H5CompoundDataset) and flush(f::H5File) can be used to manually to prematurely flush the cache of a dataset or all caches of an HDF5 file respectively.","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"Let's close the file","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"close(f)","category":"page"},{"location":"examples/hdf5/#Reading-datasets","page":"HDF5","title":"Reading datasets","text":"","category":"section"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"We open the file from the previous example with HDF5.jl, just to demonstrate that we can read it without any KM3NeT related libraries:","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"using HDF5\n\nf = h5open(\"foo.h5\")\nparticles = f[\"simulation/particles\"]\n\n@show particles[1:5]","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"Notice that HDF5.jl automatically created NamedTuple instances with the same fieldnames as our own struct definition of Particle. This means that the elements behave just like the original one regarding the field access:","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"particles[2].E","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"The whole vector can also be reinterpreted to the original struct definition with zero-cost. This can be mandatory if the data is then passed to other methods which require a specific type (in this case Particle). The following line will only work if Particle is already defined (i.e. the correspoinding module has been loaded). It is also mandatory to pass a slice (here, we pass the full slice by using [:]) to reinterpret and not the dataset itself:","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"reinterpreted_particles = reinterpret(Particle, particles[:])","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"Each element is now a proper Particle instance:","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"reinterpreted_particles[4]","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"KM3io also writes the name of the struct into the attributes of the dataset:","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"attrs(particles)[\"struct_name\"]","category":"page"},{"location":"examples/hdf5/#Adding-metadata","page":"HDF5","title":"Adding metadata","text":"","category":"section"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"Sometimes it's useful to keep track of additional metadata, e.g. a given set of parameters for a specific dataset. The addmeta() function can be used to attach key-value-pairs from a struct to a variety of HDF5 structures, like files, datasets or groups. The following example demonstrates it:","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"using KM3io\nusing HDF5\n\nstruct SimulationParameters\n    can_height::Int32\n    can_radius::Int32\n    minimum_energy::Float64\n    maximum_energy::Float64\nend\n\nsimparams = SimulationParameters(800, 200, 1e3, 1e7)\n\nf = h5open(\"simulation.h5\", \"w\")\naddmeta(f, simparams)\n\nattributes(f)","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"To access individual attributes, use HDF5.read_attribute:","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"read_attribute(f, \"can_radius\")","category":"page"},{"location":"examples/hdf5/","page":"HDF5","title":"HDF5","text":"note: Note\nIt is possible to add metadata to datasets and groups too. Make sure that the struct you pass to addmeta() only contains primitive types or strings in their fields. Arrays and other nested or compound fieldtypes are not supported by HDF5.","category":"page"},{"location":"examples/offline_data/#Offline-data","page":"Offline data","title":"Offline data","text":"","category":"section"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"Let's use the KM3NeTTestData Julia package which contains all kinds of KM3NeT related sample files. The datapath() function can be used to get a path to such a file. In the following, we will discover the numucc.root file which contains 10 muon neutrino charged current interaction events.","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"using KM3io, KM3NeTTestData\n\nf = ROOTFile(datapath(\"offline\", \"numucc.root\"))","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"The ROOTFile is the container object which gives access to both the online and offline tree. In this case, the online tree is empty","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"f.online","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"and the offline tree holds our 10 MC events:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"f.offline","category":"page"},{"location":"examples/offline_data/#Events","page":"Offline data","title":"Events","text":"","category":"section"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"To access a single event, you can use the usual indexing syntax:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"some_event = f.offline[5]","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"or ranges of events:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"events = f.offline[6:9]","category":"page"},{"location":"examples/offline_data/#Hits","page":"Offline data","title":"Hits","text":"","category":"section"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"Each event consists of a vector of hits, MC hits, tracks and MC tracks. Depending on the file, they may be empty. They are accessible via the fields .hit, .mc_hits, .trks and .mc_trks.","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"Let's grab an event:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"evt = f.offline[3]","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"and have a look at its contents:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"evt.hits","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"Let's close this file properly:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"close(f)","category":"page"},{"location":"examples/offline_data/#Usr-data","page":"Offline data","title":"Usr data","text":"","category":"section"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"You can also access \"usr\"-data, which is a dynamic placeholder (Dict{String, Float64}) to store arbitrary data. Some software store values here which are only losely defined. Ideally, if these fields are used regulary by a software, a proper definition in the KM3NeT dataformat should be created and added to the according Struct as a field.","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"Here is an example how to access the \"usr\"-data of a single event:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"f = ROOTFile(datapath(\"offline\", \"usr-sample.root\"))\n\nf.offline[1].usr","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"close(f)","category":"page"},{"location":"manual/hdf5/#HDF5-Files","page":"HDF5 Files","title":"HDF5 Files","text":"","category":"section"},{"location":"manual/hdf5/","page":"HDF5 Files","title":"HDF5 Files","text":"...","category":"page"},{"location":"#KM3io.jl","page":"Home","title":"KM3io.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KM3io.jl is a Julia library which implements high-performance I/O functions and additional utilities to deal with dataformats used in KM3NeT, e.g. ROOT (online/offline files), DETX (detector geometry and calibrations) and acoustics (waveforms and hardware). In contrast to Python, you are free to utilise as many (nested) for-loops as you like while still being as fast as in e.g. in C++.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Apropos ROOT and C++, the KM3NeT Dataformat is defined in C++ and uses the I/O functionality of the ROOT framework to create the online and offline ROOT files. Luckily, there is a pure Julia library named UnROOT.jl that provides access the the ROOT files without the need to install ROOT or the corresponding C++ library. This allows KM3io.jl to be completely free from these external dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe library is still under development so that the API might slightly change. Feedback and contributions are highly welcome!","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KM3io.jl is not an officially registered Julia package but it's available via the KM3NeT Julia registry. To add the KM3NeT Julia registry to your local Julia registry list, follow the instructions in its README or simply do","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://git.km3net.de/common/julia-registry ~/.julia/registries/KM3NeT","category":"page"},{"location":"","page":"Home","title":"Home","text":"After that, you can instal KM3io.jl just like any other Julia package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"KM3io\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nIf you encounter the error UndefVarError: libhdf5 not defined, you are probably using an M1 or M2 Mac computer. There is an issue with HDF5.jll due to a missing precompiled libhdf5 artifact for the M1 and M2 architectures, so you need to install it manually and set an envrionment variable before starting Julia. You can easily install hdf5lib using e.g. brew:brew install hdf5and then set the environment variable JULIA_HDF5_PATH to point to the location of the HDF5 files (put this line into your ~/.bashrc or ~/.zshrc or whatever shell you use):export JULIA_HDF5_PATH=/opt/homebrew/Cellar/hdf5/1.12.2_2Make sure that the path is correct, you might have a different version number.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using KM3io, KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"offline\", \"numucc.root\"))\nROOTFile{OnlineTree (0 events, 0 summaryslices), OfflineTree (10 events)}\n\njulia> f.offline\nOfflineTree (10 events)\n\njulia> some_event = f.offline[3]\nKM3io.Evt (3680 hits, 28 MC hits, 38 tracks, 12 MC tracks)","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Thanks to Johannes Schumann for providing the awesome project logo!","category":"page"},{"location":"examples/controlhost/#Accessing-Live-Data","page":"Accessing Live Data","title":"Accessing Live Data","text":"","category":"section"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"This example shows how to access and process live data (events) from the KM3NeT DAQ system. We will use two Jpp command line tools (JLigier and JRegurgitate) to create a ligier dispatcher and send triggered DAQ events to it.","category":"page"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"This example uses Jpp v14.4.3 and real data from a KM3NeT detector (online ROOT format) with the filename KM3NeT_00000075_00010275.root which can be found on the HPSS storage.","category":"page"},{"location":"examples/controlhost/#Launching-JLigier","page":"Accessing Live Data","title":"Launching JLigier","text":"","category":"section"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"We open a terminal and launch the JLigier process with a high debug level. This ligier is the central communication point and it will receive messages which are tagged with short label of maximum 8 characters.","category":"page"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"$ JLigier -P 5553 -d 3\nPort              5553\nMemory limit 16760735744\nQueue  limit        100","category":"page"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"The ligier is now running and and listening on port 5553 of all host IP addresses (including the localhost 127.0.0.1). Clients can connect to it and subscribe for a given set of message tags. Leave this terminal open.","category":"page"},{"location":"examples/controlhost/#Simulating-the-DAQ","page":"Accessing Live Data","title":"Simulating the DAQ","text":"","category":"section"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"The first client we start in new terminal session is the JRegurgitate process which takes a ROOT file (in online format), a class identifier, a few other parameters like the frequency and timeout of the messages and also the IP and port of the ligier to send to. We will use this application to simulate the KM3NeT DAQ – at least the output of the JDataFilter which is responsible for triggering events and sending them downstreams to a JLigier so that they can be picked up by the JDataWriter to store them in  ROOT files (online format).","category":"page"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"$ JRegurgitate -f /data/sea/KM3NeT_00000075_00010275.root -C JDAQEvent -R 2 -T 10000000 -H 127.0.0.1:5553","category":"page"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"This program is fairly quite but if you look at the terminal where the JLigier is running, you'll see a flood of messages, showing that a new client has connected and data is received (tagged with IO_EVT). It also prints the number of bytes of each message:","category":"page"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"$ JLigier -P 5553 -d 3\nPort              30001\nMemory limit 16760735744\nQueue  limit        100\nNew client[4]\nClient[4].read(0,1,1756)\nClient[4].read(1,2,0)\nMessage[4] IO_EVT 1772\nClient[4].read(0,1,1394)\nClient[4].read(1,2,0)\nMessage[4] IO_EVT 1410\nClient[4].read(0,1,1716)\n...\n...\n...","category":"page"},{"location":"examples/controlhost/#Retrieving-Events","page":"Accessing Live Data","title":"Retrieving Events","text":"","category":"section"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"Now open a thrid terminal and fire up the Julia REPL. With a few lines, we will able to connect to the ligier and receive DAQ events interactively.","category":"page"},{"location":"examples/controlhost/","page":"Accessing Live Data","title":"Accessing Live Data","text":"julia> using KM3io\n\njulia> c = CHClient{KM3io.DAQEvent}(ip\"127.0.0.1\", 5553)\nCHClient{DAQEvent}(ip\"127.0.0.1\", 0x7531, CHTag[CHTag(\"IO_EVT\")], Sockets.TCPSocket(RawFD(20) open, 0 bytes waiting))\n\njulia> for e in c\n         @show e\n       end\ne = DAQEvent with 126 snapshot and 7 triggered hits\ne = DAQEvent with 138 snapshot and 6 triggered hits\ne = DAQEvent with 149 snapshot and 6 triggered hits\ne = DAQEvent with 149 snapshot and 6 triggered hits\ne = DAQEvent with 136 snapshot and 6 triggered hits\n...\n...\n...","category":"page"}]
}

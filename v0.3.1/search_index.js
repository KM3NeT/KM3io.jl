var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [KM3io]","category":"page"},{"location":"api/#KM3io.AcousticSignal","page":"API","title":"KM3io.AcousticSignal","text":"AcousticSignal is a custom type with four fields to store all the information inside the raw acoustic binary files.\n\ndom_id::Int32 ID of the module\nutc_seconds:: UInt32 storing the first 4 Bytes and is a UNIX time stamp\nns_cycles:: UInt32 storing the second 4 Bytes\nsamples:: UInt32 storing the third 4 Bytes, corresponding to the number of data points accuired during the measring window\npcm:: Vector of Float32 of length frame_length, storing all other 4 Byte blocks. Each entry is a data point of the acoustic signal.\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.AcousticsTriggerParameter","page":"API","title":"KM3io.AcousticsTriggerParameter","text":"Certain parameters which define an acoustic event.\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Detector","page":"API","title":"KM3io.Detector","text":"A KM3NeT detector.\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Detector-Tuple{AbstractString}","page":"API","title":"KM3io.Detector","text":"function Detector(filename::AbstractString)\n\nCreate a Detector instance from a DETX file.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.Detector-Tuple{IO}","page":"API","title":"KM3io.Detector","text":"function Detector(io::IO)\n\nCreate a Detector instance from an IO stream.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.DetectorModule","page":"API","title":"KM3io.DetectorModule","text":"Either a base module or an optical module. A non-zero status means the module is \"not OK\". Individual bits can be read out to identify the problem (see definitions/module_status.jl for the bit positions and check them using the nthbitset() function).\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Hydrophone","page":"API","title":"KM3io.Hydrophone","text":"A hydrophone, typically installed in the base module of a KM3NeT detector's string.\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Location","page":"API","title":"KM3io.Location","text":"A module's location in the detector where string represents the detection unit identifier and floor counts from 0 from the bottom to top. Base modules are sitting on floor 0 and optical modules on floor 1 and higher.\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.PMT","page":"API","title":"KM3io.PMT","text":"The photomultiplier tube of an optical module. The id stands for the DAQ channel ID.\n\nA non-zero status means the PMT is \"not OK\". Individual bits can be read out to identify the problem (see definitions/pmt_status.jl for the bit positions and check them using the nthbitset() function).\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Tripod","page":"API","title":"KM3io.Tripod","text":"A tripod installed on the seabed which sends acoustic signals to modules.\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Waveform","page":"API","title":"KM3io.Waveform","text":"Waveform translates Emitter ID to Tripod ID.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.getindex-Tuple{DetectorModule, Any}","page":"API","title":"Base.getindex","text":"Base.getindex(d::DetectorModule, i) = d.pmts[i+1]\n\nThe index in this context is the DAQ channel ID of the PMT, which is counting from 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.read","page":"API","title":"Base.read","text":"function read(filename::AbstractString,T::Type{AcousticSignal}, overlap::Int=DAQ_ADF_ANALYSIS_WINDOW_OVERLAP)\n\nReads in a raw binary acoustics file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.read-Tuple{AbstractString, Type{AcousticsTriggerParameter}}","page":"API","title":"Base.read","text":"function read(filename::AbstractString, T::Type{AcousticsTriggerParameter})\n\nReads the 'acousticstriggerparameters.txt' file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.read-Tuple{AbstractString, Type{Hydrophone}}","page":"API","title":"Base.read","text":"function read(filename::AbstractString, T::Type{Hydrophone})\n\nReads a vector of Hydrophones from an ASCII file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.read-Tuple{AbstractString, Type{Tripod}}","page":"API","title":"Base.read","text":"function read(filename:AbstractString, T::Type{Tripod})\n\nReads a vector of Tripods from an ASCII file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.read-Tuple{AbstractString, Type{Waveform}}","page":"API","title":"Base.read","text":"function read(filename::AbstractString, T::Type{Waveform})\n\nReads the waveform ASCII file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{AbstractString, Vector{Tripod}}","page":"API","title":"Base.write","text":"function write(filename::AbstractString, tripods::Dict{Int8, Tripod})\n\nWrites the position of tripods out into an ASCII file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{IO, Detector}","page":"API","title":"Base.write","text":"function write(io::IO, d::Detector; version=:same)\n\nWrites the detector to a DETX formatted file. The target version can be specified via the version keyword. Note that if converting to higher versions, missing parameters will be filled with reasonable default values. In case of downgrading, information will be lost.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io._categorize-Union{Tuple{F}, Tuple{T}, Tuple{Val{F}, Vector{T}}} where {T, F}","page":"API","title":"KM3io._categorize","text":"_categorize(field::Val{F}, elements::Array{T, 1}) -> Dict\n\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io._extract_comments-Union{Tuple{T}, Tuple{Vector{T}, T}} where T<:AbstractString","page":"API","title":"KM3io._extract_comments","text":"function _extract_comments(lines<:Vector{AbstractString}, prefix<:AbstractString)\n\nReturns only the lines which are comments, identified by the prefix. The prefix is omitted.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.calibrate-Tuple{Detector, Any}","page":"API","title":"KM3io.calibrate","text":"calibrate(det, hits)\n\n\nApply geometry and time calibration to given hits.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.categorize","page":"API","title":"KM3io.categorize","text":"categorize(field, elements)\n\ndefined at /builds/common/KM3io.jl/src/tools.jl:108.\n\nCategorise the struct elements of a vector by a given field into a dictionary of T.field => Vector{T}.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.categorize-Tuple{Symbol, Vector}","page":"API","title":"KM3io.categorize","text":"categorize(field::Symbol, elements::Vector) -> Dict\n\n\nExamples\n\njulia> using NeRCA\n\njulia> struct PMT\n         dom_id\n         time\n       end\n\njulia> pmts = [PMT(2, 10.4), PMT(4, 23.5), PMT(2, 42.0)];\n\njulia> categorize(:dom_id, pmts)\nDict{Any, Vector{PMT}} with 2 entries:\n  4 => [PMT(4, 23.5)]\n  2 => [PMT(2, 10.4), PMT(2, 42.0)]\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.floordist-Tuple{Detector}","page":"API","title":"KM3io.floordist","text":"function floordist(calib::Calibration)\n\nCalculates the average floor distance between neighboured modules.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.hydrophoneenabled-Tuple{DetectorModule}","page":"API","title":"KM3io.hydrophoneenabled","text":"function hydrophonenabled(m::DetectorModule)\n\nReturn true if the hydrophone is enabled, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.most_frequent-Tuple{Any}","page":"API","title":"KM3io.most_frequent","text":"function most_frequent(iterable)\n\nReturn the most frequent value of a given iterable.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.most_frequent-Tuple{Function, Any}","page":"API","title":"KM3io.most_frequent","text":"function most_frequent(f::Function, iterable; rettype=Int)\n\nReturn the most frequent value of a given iterable based on the return value of a function f which returns (hashable) values of rettype.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.nthbitset-Tuple{Any, Any}","page":"API","title":"KM3io.nthbitset","text":"nthbitset(n, a) = !Bool((a >> (n - 1)) & 1)\n\nReturn true if the n-th bit of a is set, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.piezoenabled-Tuple{DetectorModule}","page":"API","title":"KM3io.piezoenabled","text":"function piezoenabled(m::DetectorModule)\n\nReturn true if the piezo is enabled, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#KM3io.slew-Tuple{Integer}","page":"API","title":"KM3io.slew","text":"slew(tot)\n\n\nReturn the time slewing for a ToT.\n\n\n\n\n\n","category":"method"},{"location":"#KM3io.jl","page":"Home","title":"KM3io.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"KM3io.jl is a pure Julia library which implements high-performance I/O functions and utilities to deal with dataformats used in KM3NeT, e.g. ROOT (online/offline), detx and acoustics. In contrast to Python, you are free to utilise as many (nested) for-loops as you like while still being as fast as C++ counterparts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The library is still under development so that the API might slightly change.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KM3io.jl is not an officially registered Julia package but it's available via the KM3NeT Julia registry. To add the KM3NeT Julia registry, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://git.km3net.de/common/julia-registry ~/.julia/registries/KM3NeT","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the registry is added, Julia will make sure to keep it up to date and pick it whenever you install a package which is registered there.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install KM3io.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"KM3io\")","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"#Reading-online-(DAQ-or-RBR)-event-data","page":"Home","title":"Reading online (DAQ or RBR) event data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Accessing the data is as easy as opening it via OnlineFile(\"path/to/file.root\") and using indices/slices or iteration. Everything is lazily loaded so that the data is only occupying memory when it's actually accessed. In the examples below, we use KM3NeTTestdata to get access to small sample files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using KM3io\n\njulia> using KM3NeTTestData\n\njulia> f = OnlineFile(datapath(\"online\", \"km3net_online.root\"))\nOnlineFile with 3 events\n\njulia> event = f.events[1]\nKM3io.DAQEvent with 96 snapshot and 18 triggered hits\n\njulia> event.triggered_hits[4:8]\n5-element Vector{KM3io.TriggeredHit}:\n KM3io.TriggeredHit(808447186, 0x00, 30733214, 0x19, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x01, 30733214, 0x15, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x02, 30733215, 0x15, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x03, 30733214, 0x1c, 0x0000000000000016)\n KM3io.TriggeredHit(808451907, 0x07, 30733441, 0x1e, 0x0000000000000004)\n\njulia> for event ∈ f.events\n           @show event.header.frame_index length(event.snapshot_hits)\n       end\nevent.header.frame_index = 127\nlength(event.snapshot_hits) = 96\nevent.header.frame_index = 127\nlength(event.snapshot_hits) = 124\nevent.header.frame_index = 129\nlength(event.snapshot_hits) = 78","category":"page"},{"location":"#Summaryslices-and-Summary-Frames","page":"Home","title":"Summaryslices and Summary Frames","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Summaryslices are generated from timeslices (raw hit data) and are produced by the DataFilter. A slice contains the data of 100ms and is divided into so-called frames, each corresponding to the data of a single optical module. Due to the high amount of data, the storage of timeslices is usually reduced by a factor of 10-100 after the event triggering stage. However, summaryslices are covering the full data taking period. They however do not contain hit data but only the rates of the PMTs encoded into a single byte, which therefore is only capable to store 256 different values. The actual rate is calcuated by a helper function (TODO).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The summaryslices are accessible using the .summaryslices attribute of the OnlineFile instance:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using KM3io, UnROOT, KM3NeTTestData\n\njulia> f = OnlineFile(datapath(\"online\", \"km3net_online.root\"))\nOnlineFile with 3 events\n\njulia> f.summaryslices\nKM3io.SummarysliceContainer with 3 summaryslices\n\njulia> for s ∈ f.summaryslices\n           @show s.header\n       end\ns.header = KM3io.SummarysliceHeader(44, 6633, 126, KM3io.UTCExtended(0x5dc6018c, 0x23c34600, false))\ns.header = KM3io.SummarysliceHeader(44, 6633, 127, KM3io.UTCExtended(0x5dc6018c, 0x29b92700, false))\ns.header = KM3io.SummarysliceHeader(44, 6633, 128, KM3io.UTCExtended(0x5dc6018c, 0x2faf0800, false))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To access the actual PMT rates and flags (e.g. for high-rate veto or FIFO status), the s.frames can be used (TODO).","category":"page"}]
}

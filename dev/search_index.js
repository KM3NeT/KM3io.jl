var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Basic-Data-Structures","page":"API","title":"Basic Data Structures","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Position\nDirection\nLocation","category":"page"},{"location":"api/#KM3io.Position","page":"API","title":"KM3io.Position","text":"struct Position{T} <: StaticArraysCore.FieldVector{3, T}\n\nA vector to represent a position in 3D.\n\nFields\n\nx::Any\ny::Any\nz::Any\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Direction","page":"API","title":"KM3io.Direction","text":"struct Direction{T} <: StaticArraysCore.FieldVector{3, T}\n\nA vector to represent a direction in 3D.\n\nFields\n\nx::Any\ny::Any\nz::Any\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Location","page":"API","title":"KM3io.Location","text":"struct Location\n\nA module's location in the detector where string represents the detection unit identifier and floor counts from 0 from the bottom to top. Base modules are sitting on floor 0 and optical modules on floor 1 and higher.\n\nFields\n\nstring::Int32\nfloor::Int8\n\n\n\n\n\n","category":"type"},{"location":"api/#Offline-Format","page":"API","title":"Offline Format","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Trk\nMcTrk\nEvt","category":"page"},{"location":"api/#KM3io.Trk","page":"API","title":"KM3io.Trk","text":"struct Trk\n\nRepresents a reconstructed \"track\", which can be e.g. a muon track but also a shower.\n\nFields\n\nid::Int64\npos::Position{Float64}\ndir::Direction{Float64}\nt::Float64\nE::Float64\nlen::Float64\nlik::Float64\nrec_type::Int32\nrec_stages::Vector{Int32}\nfitinf::Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#Online-Format","page":"API","title":"Online Format","text":"","category":"section"},{"location":"api/#Hardware","page":"API","title":"Hardware","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"PMT\nDetectorModule\nDetector\nHydrophone\nTripod\npiezoenabled\nhydrophoneenabled\ncenter","category":"page"},{"location":"api/#KM3io.PMT","page":"API","title":"KM3io.PMT","text":"struct PMT\n\nThe photomultiplier tube of an optical module. The id stands for the DAQ channel ID.\n\nA non-zero status means the PMT is \"not OK\". Individual bits can be read out to identify the problem (see definitions/pmt_status.jl for the bit positions and check them using the nthbitset() function).\n\nFields\n\nid::Int32\npos::Position{Float64}\ndir::Direction{Float64}\nt₀::Float64\nstatus::Union{Missing, Int32}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.DetectorModule","page":"API","title":"KM3io.DetectorModule","text":"struct DetectorModule\n\nEither a base module or an optical module. A non-zero status means the module is \"not OK\". Individual bits can be read out to identify the problem (see definitions/module_status.jl for the bit positions and check them using the nthbitset() function).\n\nFields\n\nid::Int32\npos::Position{Float64}\nlocation::Location\nn_pmts::Int8\npmts::Vector{PMT}\nq::Union{Missing, Quaternion{Float64}}\nstatus::Int32\nt₀::Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Detector","page":"API","title":"KM3io.Detector","text":"struct Detector\n\nA KM3NeT detector.\n\nFields\n\nversion::Int8\nid::Int32\nvalidity::Union{Missing, KM3io.DateRange}\npos::Union{Missing, UTMPosition{Float64}}\nutm_ref_grid::Union{Missing, String}\nn_modules::Int32\nmodules::Dict{Int32, DetectorModule}\nlocations::Dict{Tuple{Int64, Int64}, DetectorModule}\nstrings::Vector{Int64}\ncomments::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Hydrophone","page":"API","title":"KM3io.Hydrophone","text":"struct Hydrophone\n\nA hydrophone, typically installed in the base module of a KM3NeT detector's string.\n\nFields\n\nlocation::Location\npos::Position{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Tripod","page":"API","title":"KM3io.Tripod","text":"struct Tripod\n\nA tripod installed on the seabed which sends acoustic signals to modules.\n\nFields\n\nid::Int8\npos::Position{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.piezoenabled","page":"API","title":"KM3io.piezoenabled","text":"piezoenabled(m::DetectorModule) -> Bool\n\n\nfunction piezoenabled(m::DetectorModule)\n\nReturn true if the piezo is enabled, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.hydrophoneenabled","page":"API","title":"KM3io.hydrophoneenabled","text":"hydrophoneenabled(m::DetectorModule) -> Bool\n\n\nfunction hydrophonenabled(m::DetectorModule)\n\nReturn true if the hydrophone is enabled, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.center","page":"API","title":"KM3io.center","text":"center(m::DetectorModule) -> Position{Float64}\n\n\nCalculate the centre of a module by fitting the crossing point of the PMT axes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optical-Data","page":"API","title":"Optical Data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Acoustics","page":"API","title":"Acoustics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Waveform\nAcousticSignal\nAcousticsTriggerParameter","category":"page"},{"location":"api/#KM3io.Waveform","page":"API","title":"KM3io.Waveform","text":"struct Waveform\n\nWaveform translates Emitter ID to Tripod ID.\n\nFields\n\nids::Dict{Int8, Int8}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.AcousticSignal","page":"API","title":"KM3io.AcousticSignal","text":"struct AcousticSignal\n\nAcousticSignal is a custom type with four fields to store all the information inside the raw acoustic binary files.\n\ndom_id::Int32 ID of the module\nutc_seconds:: UInt32 storing the first 4 Bytes and is a UNIX time stamp\nns_cycles:: UInt32 storing the second 4 Bytes\nsamples:: UInt32 storing the third 4 Bytes, corresponding to the number of data points accuired during the measring window\npcm:: Vector of Float32 of length frame_length, storing all other 4 Byte blocks. Each entry is a data point of the acoustic signal.\n\nFields\n\ndom_id::Int32\nutc_seconds::UInt32\nns_cycles::UInt32\nsamples::UInt32\npcm::Vector{Float32}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.AcousticsTriggerParameter","page":"API","title":"KM3io.AcousticsTriggerParameter","text":"struct AcousticsTriggerParameter\n\nCertain parameters which define an acoustic event.\n\nFields\n\nq::Float64\ntmax::Float64\nnmin::Int32\n\n\n\n\n\n","category":"type"},{"location":"api/#Calibration","page":"API","title":"Calibration","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"calibrate\nfloordist\nslew","category":"page"},{"location":"api/#KM3io.calibrate","page":"API","title":"KM3io.calibrate","text":"calibrate(\n    det::Detector,\n    hits\n) -> Vector{KM3io.CalibratedDAQHit}\n\n\nApply geometry and time calibration to given hits.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.floordist","page":"API","title":"KM3io.floordist","text":"floordist(det::Detector) -> Float64\n\n\nCalculates the average floor distance between neighboured modules.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.slew","page":"API","title":"KM3io.slew","text":"slew(tot::Integer) -> Any\n\n\nReturn the time slewing for a ToT.\n\n\n\n\n\n","category":"function"},{"location":"api/#Physics","page":"API","title":"Physics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"cherenkov\nCherenkovPhoton\nK40Rates","category":"page"},{"location":"api/#KM3io.cherenkov","page":"API","title":"KM3io.cherenkov","text":"cherenkov(track, hits::Vector{CalibratedEvtHit}) -> Vector\n\n\nCalculates the parameters of cherenkov photons emitted from a track and hitting the PMTs represented as (calibrated) hits. The return value is Vector{([CherenkovPhoton]){@ref}} which holds information about the closest distance to track, the time residual, arrival time, impact angle, photon travel distance, track travel distance and photon travel direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.CherenkovPhoton","page":"API","title":"KM3io.CherenkovPhoton","text":"struct CherenkovPhoton\n\nA Cherenkov photon with parameters calculated from its inducing track. See cherenkov() for more information.\n\nFields\n\nd_closest::Float64\nd_photon::Float64\nd_track::Float64\nt::Float64\nΔt::Float64\nimpact_angle::Float64\ndir::Direction{Float64}\n\n\n\n\n\n","category":"type"},{"location":"api/#Trigger","page":"API","title":"Trigger","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"is3dmuon\nis3dshower\nismxshower\nisnb","category":"page"},{"location":"api/#KM3io.is3dmuon","page":"API","title":"KM3io.is3dmuon","text":"is3dmuon(e::KM3io.DAQEvent) -> Bool\n\n\nis3dmuon(e)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:11.\n\nReturn true the 3D Muon trigger bit is set.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.is3dshower","page":"API","title":"KM3io.is3dshower","text":"is3dshower(e::KM3io.DAQEvent) -> Bool\n\n\nis3dshower(e)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:19.\n\nReturn true if the 3D Shower trigger bit is set.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.ismxshower","page":"API","title":"KM3io.ismxshower","text":"ismxshower(x) -> Bool\n\n\nismxshower(x)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:27.\n\nismxshower(e)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:28.\n\nReturn true if the MX Shower trigger bit is set.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.isnb","page":"API","title":"KM3io.isnb","text":"isnb(x) -> Bool\n\n\nisnb(x)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:35.\n\nisnb(e)\n\ndefined at /builds/common/KM3io.jl/src/tools/trigger.jl:36.\n\nReturn true if the NanoBeacon trigger bit is set.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tools","page":"API","title":"Tools","text":"","category":"section"},{"location":"api/#General-tools","page":"API","title":"General tools","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"categorize\nnthbitset\nmost_frequent","category":"page"},{"location":"api/#KM3io.categorize","page":"API","title":"KM3io.categorize","text":"categorize(field::Symbol, elements::Vector) -> Dict\n\n\nCategorise the struct elements of a vector by a given field into a dictionary of T.field => Vector{T}.\n\nExamples\n\njulia> using KM3io\n\njulia> struct PMT  # just an ad-hoc PMT struct for demonstration purposes\n         dom_id\n         time\n       end\n\njulia> pmts = [PMT(2, 10.4), PMT(4, 23.5), PMT(2, 42.0)];\n\njulia> categorize(:dom_id, pmts)\nDict{Any, Vector{PMT}} with 2 entries:\n  4 => [PMT(4, 23.5)]\n  2 => [PMT(2, 10.4), PMT(2, 42.0)]\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.nthbitset","page":"API","title":"KM3io.nthbitset","text":"nthbitset(n, a) -> Any\n\n\nReturn true if the n-th bit of a is set, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.most_frequent","page":"API","title":"KM3io.most_frequent","text":"most_frequent(iterable) -> Any\n\n\nReturn the most frequent value of a given iterable.\n\n\n\n\n\nmost_frequent(f::Function, iterable; rettype) -> Int64\n\n\nReturn the most frequent value of a given iterable based on the return value of a function f which returns (hashable) values of rettype.\n\n\n\n\n\n","category":"function"},{"location":"api/#Reconstruction","page":"API","title":"Reconstruction","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"besttrack\nbestjppmuon\nbestjppshower\nbestaashower\nRecStageRange\nhashistory","category":"page"},{"location":"api/#KM3io.besttrack","page":"API","title":"KM3io.besttrack","text":"besttrack(\n    e::KM3io.Evt,\n    rec_type::Integer,\n    rsr::RecStageRange\n) -> Union{Nothing, Trk}\n\n\nReturn the best reconstructed track for a given reconstruction type and reconstruction stage range. If no track could be found, nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#KM3io.RecStageRange","page":"API","title":"KM3io.RecStageRange","text":"struct RecStageRange{T<:Integer}\n\nThis struct is used to represent a range of reconstruction stages. These are well-defined integers (see KM3NeT Dataformat) for each reconstruction algorithm and are stored in a vector named rec_stages of each Trk.\n\njulia> using KM3io\n\njulia> rsr = RecStageRange(KM3io.RECONSTRUCTION.JMUONBEGIN, KM3io.RECONSTRUCTION.JMUONEND)\nRecStageRange{Int64}(0, 99)\n\njulia> KM3io.RECONSTRUCTION.JMUONSIMPLEX ∈ rsr\ntrue\n\njulia> KM3io.RECONSTRUCTION.AASHOWERFITPREFIT ∈ rsr\nfalse\n\njulia> 23 ∈ rsr\ntrue\n\njulia> 523 ∈ rsr\nfalse\n\nFields\n\nlower::Integer\nupper::Integer\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.hashistory","page":"API","title":"KM3io.hashistory","text":"hashistory(\n    t::Trk,\n    rec_type::Integer,\n    rsr::RecStageRange\n) -> Bool\n\n\nReturns true if a track with a given rec_type contains all the reconstruction stages in rsr::RecStageRange.\n\n\n\n\n\nhashistory(\n    t::Trk,\n    rec_type::Integer,\n    rec_stage::Integer\n) -> Union{Missing, Bool}\n\n\nReturns true if a track with a given rec_type contains the rec_stage.\n\n\n\n\n\n","category":"function"},{"location":"examples/cherenkov_times/#Cherenkov-times","page":"Cherenkov times","title":"Cherenkov times","text":"","category":"section"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"In this example, we will pick the best reconstructed muon (from the Jpp muon reconstruction chain JMuon) in each event and calculate the Cherenkov hit time residuals for each triggered hit.","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"We open the numucc.root file from the KM3NeTTestData package:","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"using KM3io, KM3NeTTestData\n\nf = ROOTFile(datapath(\"offline\", \"numucc.root\"))","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"Each event holds a vector of reconstructed tracks (Vector{Trk}) behind the .trks field. This vector contains different stages of reconstruction results from a variety of reconstruction algorithms (JMuon, JShower, aashower etc.). KM3io.jl exports helper functions to pick the best reconstructed track for a given reconstruction algorithm. The logic is based on the reference implementation in KM3NeT DataFormat tools. The function bestjppmuon() can be used to select the best reconstructed JMuon for a given event:","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"evt = f.offline[1]\nm = bestjppmuon(evt)","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"We now use this track as a seed to calculate the Cherenkov photon (see CherenkovPhoton) parameters using cherenkov() for each hit in the event.","category":"page"},{"location":"examples/cherenkov_times/","page":"Cherenkov times","title":"Cherenkov times","text":"cherenkov_photons = cherenkov(m, evt.hits)","category":"page"},{"location":"manual/rootfiles/#ROOT-Files","page":"ROOT Files","title":"ROOT Files","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The two main types of ROOT files in KM3NeT are the online and offline files, however, both types can be mixed together as the data is stored in distinct ROOT trees. UnROOT has a single ROOTFile type to represent a KM3NeT ROOT file which can be used to access both the online and offline information. This section describes what kind of data is stored in each tree and how to access them.","category":"page"},{"location":"manual/rootfiles/#Offline-Dataformat","page":"ROOT Files","title":"Offline Dataformat","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The offline dataformat is used to store Monte Carlo (MC) simulations and reconstruction results. The OfflineTree type represents an actual offline file and it is essentially a vector of events (Vector{Evt}) with some fancy caching, lazy access and slicing magic. The offline tree is accessible via the .offline field of the ROOTFile type.","category":"page"},{"location":"manual/rootfiles/#MC-Header","page":"ROOT Files","title":"MC Header","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The MC header stores metadata related to the simulation chain. The individual entries can be accessed as properties, as shown below.","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"julia> using KM3io, KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"offline\", \"numucc.root\"))\nROOTFile{OnlineTree (0 events, 0 summaryslices), OfflineTree (10 events)}\n\njulia> f.offline\nOfflineTree (10 events)\n\njulia> f.offline.header\nMCHeader\n  DAQ => (livetime = 394,)\n  PDF => (i1 = 4, i2 = 58)\n  XSecFile => Any[]\n  can => (zmin = 0, zmax = 1027, r = 888.4)\n  can_user => [0.0, 1027.0, 888.4]\n  coord_origin => (x = 0, y = 0, z = 0)\n  cut_in => (Emin = 0, Emax = 0, cosTmin = 0, cosTmax = 0)\n  cut_nu => (Emin = 100, Emax = 1.0e8, cosTmin = -1, cosTmax = 1)\n  cut_primary => (Emin = 0, Emax = 0, cosTmin = 0, cosTmax = 0)\n  cut_seamuon => (Emin = 0, Emax = 0, cosTmin = 0, cosTmax = 0)\n  decay => [\"doesnt\", \"happen\"]\n  detector => NOT\n  drawing => Volume\n  end_event => Any[]\n  genhencut => (gDir = 2000, Emin = 0)\n  genvol => (zmin = 0, zmax = 1027, r = 888.4, volume = 2.649e9, numberOfEvents = 100000)\n  kcut => 2\n  livetime => (numberOfSeconds = 0, errorOfSeconds = 0)\n  model => (interaction = 1, muon = 2, scattering = 0, numberOfEnergyBins = 1, field_4 = 12)\n  muon_desc_file => Any[]\n  ngen => 100000.0\n  norma => (primaryFlux = 0, numberOfPrimaries = 0)\n  nuflux => Real[0, 3, 0, 0.5, 0.0, 1.0, 3.0]\n  physics => (program = \"GENHEN\", version = \"7.2-220514\", date = 181116, time = 1138)\n  seed => (program = \"GENHEN\", level = 3, iseed = 305765867, field_3 = 0, field_4 = 0)\n  simul => (program = \"JSirene\", version = 11012, date = \"11/17/18\", time = 7)\n  sourcemode => diffuse\n  spectrum => (alpha = -1.4,)\n  start_run => 1\n  target => isoscalar\n  usedetfile => false\n  xlat_user => 0.63297\n  xparam => OFF\n  zed_user => [0.0, 3450.0]\n\n\njulia> f.offline.header.genvol\n(zmin = 0, zmax = 1027, r = 888.4, volume = 2.649e9, numberOfEvents = 100000)\n\njulia> f.offline.header.genvol.volume\n2.649e9","category":"page"},{"location":"manual/rootfiles/#Event-data","page":"ROOT Files","title":"Event data","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The following REPL session shows how to open a file, access individual events or slices of events, loop through events and access e.g. the tracks which are stored in the events.","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"julia> using KM3io, KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"offline\", \"km3net_offline.root\"))\nROOTFile{OfflineTree (10 events)}\n\njulia> f.offline[5]\nKM3io.Evt (83 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n\njulia> f.offline[3:5]\n3-element Vector{KM3io.Evt}:\n KM3io.Evt (318 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n KM3io.Evt (157 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n KM3io.Evt (83 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n\njulia> event = f.offline[1]\nKM3io.Evt (176 hits, 0 MC hits, 56 tracks, 0 MC tracks)\n\njulia> event.trks[:4]\nKM3io.Trk(4, [448.25834890057024, ... , 291.64653112688273, 4000)\n\njulia> event.trks[1:4]\n4-element Vector{KM3io.Trk}:\n KM3io.Trk(1, [445.835395997812, ... , 294.6407542676734, 4000)\n KM3io.Trk(2, [445.835395997812, ... , 294.6407542676734, 4000)\n KM3io.Trk(3, [448.136188112227, ... , 294.6407542676734, 4000)\n KM3io.Trk(4, [448.258348900570, ... , 291.64653112688273, 4000)\n\njulia> for event in f.offline\n           @show event\n       end\nevent = KM3io.Evt (176 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (125 hits, 0 MC hits, 55 tracks, 0 MC tracks)\nevent = KM3io.Evt (318 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (157 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (83 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (60 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (71 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (84 hits, 0 MC hits, 56 tracks, 0 MC tracks)\nevent = KM3io.Evt (255 hits, 0 MC hits, 54 tracks, 0 MC tracks)\nevent = KM3io.Evt (105 hits, 0 MC hits, 56 tracks, 0 MC tracks)","category":"page"},{"location":"manual/rootfiles/#Online-Dataformat","page":"ROOT Files","title":"Online Dataformat","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The online dataformat refers to the dataformat which is written by the data acquisition system (DAQ) of the KM3NeT detectors, more precisely, the ROOT files produced by the JDataFilter which is part of the Jpp framework. The very same format is used in run-by-run (RBR) Monte Carlo (MC) productions, which mimic the detector response and therefore produce similarly structured data. The online data can be accessed via the .online field of the ROOTFile type.","category":"page"},{"location":"manual/rootfiles/#Event-data-2","page":"ROOT Files","title":"Event data","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The events are accessible via ROOTFile(filename).online.events which supports indexing, slicing and iteration, just like the we have seen above, in case of the offline events. Notice however that the online format also contains other types of trees, that's why the explicit .events field is needed. Everything is lazily loaded so that the data is only occupying memory when it's actually accessed, similar to the offline access. In the examples below, we use KM3NeTTestdata to get access to small sample files.","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"julia> using KM3io\n\njulia> using KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"online\", \"km3net_online.root\"))\nROOTFile{OnlineTree (3 events, 3 summaryslices), OfflineTree (0 events)}\n\njulia> event = f.online.events[1]\nKM3io.DAQEvent with 96 snapshot and 18 triggered hits\n\njulia> event.triggered_hits[4:8]\n5-element Vector{KM3io.TriggeredHit}:\n KM3io.TriggeredHit(808447186, 0x00, 30733214, 0x19, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x01, 30733214, 0x15, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x02, 30733215, 0x15, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x03, 30733214, 0x1c, 0x0000000000000016)\n KM3io.TriggeredHit(808451907, 0x07, 30733441, 0x1e, 0x0000000000000004)\n\njulia> for event ∈ f.online.events\n           @show event.header.frame_index length(event.snapshot_hits)\n       end\nevent.header.frame_index = 127\nlength(event.snapshot_hits) = 96\nevent.header.frame_index = 127\nlength(event.snapshot_hits) = 124\nevent.header.frame_index = 129\nlength(event.snapshot_hits) = 78","category":"page"},{"location":"manual/rootfiles/#Summaryslices-and-Summary-Frames","page":"ROOT Files","title":"Summaryslices and Summary Frames","text":"","category":"section"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"Summaryslices are generated from timeslices (raw hit data) and are produced by the DataFilter. A slice contains the data of 100ms and is divided into so-called frames, each corresponding to the data of a single optical module. Due to the high amount of data, the storage of timeslices is usually reduced by a factor of 10-100 after the event triggering stage. However, summaryslices are covering the full data taking period. They however do not contain hit data but only the rates of the PMTs encoded into a single byte, which therefore is only capable to store 256 different values. The actual rate is calcuated by a helper function (TODO).","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"The summaryslices are accessible using the .summaryslices attribute of the OnlineTree instance, which again is hidden behind the .online field of a ROOTFile:","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"julia> using KM3io, UnROOT, KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"online\", \"km3net_online.root\"))\nROOTFile{OnlineTree (3 events, 3 summaryslices), OfflineTree (0 events)}\n\njulia> f.online.summaryslices\nKM3io.SummarysliceContainer with 3 summaryslices\n\njulia> for s ∈ f.online.summaryslices\n           @show s.header\n       end\ns.header = KM3io.SummarysliceHeader(44, 6633, 126, KM3io.UTCExtended(0x5dc6018c, 0x23c34600, false))\ns.header = KM3io.SummarysliceHeader(44, 6633, 127, KM3io.UTCExtended(0x5dc6018c, 0x29b92700, false))\ns.header = KM3io.SummarysliceHeader(44, 6633, 128, KM3io.UTCExtended(0x5dc6018c, 0x2faf0800, false))","category":"page"},{"location":"manual/rootfiles/","page":"ROOT Files","title":"ROOT Files","text":"To access the actual PMT rates and flags (e.g. for high-rate veto or FIFO status), the s.frames can be used (TODO).","category":"page"},{"location":"examples/offline_data/#Offline-data","page":"Offline data","title":"Offline data","text":"","category":"section"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"Let's use the KM3NeTTestData Julia package which contains all kinds of KM3NeT related sample files. The datapath() function can be used to get a path to such a file. In the following, we will discover the numucc.root file which contains 10 muon neutrino charged current interaction events.","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"using KM3io, KM3NeTTestData\n\nf = ROOTFile(datapath(\"offline\", \"numucc.root\"))","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"The ROOTFile is the container object which gives access to both the online and offline tree. In this case, the online tree is empty","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"f.online","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"and the offline tree holds our 10 MC events:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"f.offline","category":"page"},{"location":"examples/offline_data/#Events","page":"Offline data","title":"Events","text":"","category":"section"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"To access a single event, you can use the usual indexing syntax:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"some_event = f.offline[5]","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"or ranges of events:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"events = f.offline[6:9]","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"Each event consists of a vector of hits, MC hits, tracks and MC tracks. Depending on the file, they may be empty. They are accessible via the fields .hit, .mc_hits, .trks and .mc_trks.","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"Let's grab an event:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"evt = f.offline[3]","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"and have a look at its contents:","category":"page"},{"location":"examples/offline_data/","page":"Offline data","title":"Offline data","text":"evt.hits","category":"page"},{"location":"#KM3io.jl","page":"Home","title":"KM3io.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KM3io.jl is a Julia library which implements high-performance I/O functions and additional utilities to deal with dataformats used in KM3NeT, e.g. ROOT (online/offline files), DETX (detector geometry and calibrations) and acoustics (waveforms and hardware). In contrast to Python, you are free to utilise as many (nested) for-loops as you like while still being as fast as in e.g. in C++.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Apropos ROOT and C++, the KM3NeT Dataformat is defined in C++ and uses the I/O functionality of the ROOT framework to create the online and offline ROOT files. Luckily, there is a pure Julia library named UnROOT.jl that provides access the the ROOT files without the need to install ROOT or the corresponding C++ library. This allows KM3io.jl to be completely free from these external dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe library is still under development so that the API might slightly change. Feedback and contributions are highly welcome!","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KM3io.jl is not an officially registered Julia package but it's available via the KM3NeT Julia registry. To add the KM3NeT Julia registry to your local Julia registry list, follow the instructions in its README or simply do","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://git.km3net.de/common/julia-registry ~/.julia/registries/KM3NeT","category":"page"},{"location":"","page":"Home","title":"Home","text":"After that, you can instal KM3io.jl just like any other Julia package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"KM3io\")","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using KM3io, KM3NeTTestData\n\njulia> f = ROOTFile(datapath(\"offline\", \"numucc.root\"))\nROOTFile{OnlineTree (0 events, 0 summaryslices), OfflineTree (10 events)}\n\njulia> f.offline\nOfflineTree (10 events)\n\njulia> some_event = f.offline[3]\nKM3io.Evt (3680 hits, 28 MC hits, 38 tracks, 12 MC tracks)","category":"page"},{"location":"#TODOs","page":"Home","title":"TODOs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These are mostly low-hanging fruits, so feel free to contribute! ;)","category":"page"},{"location":"","page":"Home","title":"Home","text":"[x] Best track selection (cf. the implementation in km3io or KM3NeT Dataformat, latter being much more closer to the Julia implementation since we don't need all the fancy masking/slicing magic as in Python)\n[ ] Hit calibration for the offline format: fairly straight forward\n[ ] Event+Summaryslice matching: for a given event, return the correct summaryslice to be able to query the most recent PMT rates\n[ ] Optimise type hierarchy\n[ ] Examples!","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Thanks to Johannes Schumann for providing the awesome project logo!","category":"page"}]
}

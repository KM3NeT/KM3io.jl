var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#Basic-Data-Structures","page":"API","title":"Basic Data Structures","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Position\nDirection\nLocation","category":"page"},{"location":"api/#KM3io.Position","page":"API","title":"KM3io.Position","text":"A vector to represent a position in 3D.\n\nFields\n\nx::Any\ny::Any\nz::Any\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Direction","page":"API","title":"KM3io.Direction","text":"A vector to represent a direction in 3D.\n\nFields\n\nx::Any\ny::Any\nz::Any\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Location","page":"API","title":"KM3io.Location","text":"A module's location in the detector where string represents the detection unit identifier and floor counts from 0 from the bottom to top. Base modules are sitting on floor 0 and optical modules on floor 1 and higher.\n\nFields\n\nstring::Int32\nfloor::Int8\n\n\n\n\n\n","category":"type"},{"location":"api/#Hardware-Components","page":"API","title":"Hardware Components","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"PMT\nDetectorModule\nDetector","category":"page"},{"location":"api/#KM3io.PMT","page":"API","title":"KM3io.PMT","text":"The photomultiplier tube of an optical module. The id stands for the DAQ channel ID.\n\nA non-zero status means the PMT is \"not OK\". Individual bits can be read out to identify the problem (see definitions/pmt_status.jl for the bit positions and check them using the nthbitset() function).\n\nFields\n\nid::Int32\npos::Position\ndir::Direction\nt₀::Float64\nstatus::Union{Missing, Int32}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.DetectorModule","page":"API","title":"KM3io.DetectorModule","text":"Either a base module or an optical module. A non-zero status means the module is \"not OK\". Individual bits can be read out to identify the problem (see definitions/module_status.jl for the bit positions and check them using the nthbitset() function).\n\nFields\n\nid::Int32\npos::Position\nlocation::Location\nn_pmts::Int8\npmts::Vector{PMT}\nq::Union{Missing, Quaternion}\nstatus::Int32\nt₀::Float64\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Detector","page":"API","title":"KM3io.Detector","text":"A KM3NeT detector.\n\nFields\n\nversion::Int8\nid::Int32\nvalidity::Union{Missing, KM3io.DateRange}\npos::Union{Missing, UTMPosition}\nutm_ref_grid::Union{Missing, String}\nn_modules::Int32\nmodules::Dict{Int32, DetectorModule}\nlocations::Dict{Tuple{Int64, Int64}, DetectorModule}\nstrings::Vector{Int64}\ncomments::Vector{String}\n\n\n\n\n\n","category":"type"},{"location":"api/#Acoustics","page":"API","title":"Acoustics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Waveform\nAcousticSignal\nHydrophone\nTripod","category":"page"},{"location":"api/#KM3io.Waveform","page":"API","title":"KM3io.Waveform","text":"Waveform translates Emitter ID to Tripod ID.\n\nFields\n\nids::Dict{Int8, Int8}\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Hydrophone","page":"API","title":"KM3io.Hydrophone","text":"A hydrophone, typically installed in the base module of a KM3NeT detector's string.\n\nFields\n\nlocation::Location\npos::Position\n\n\n\n\n\n","category":"type"},{"location":"api/#KM3io.Tripod","page":"API","title":"KM3io.Tripod","text":"A tripod installed on the seabed which sends acoustic signals to modules.\n\nFields\n\nid::Int8\npos::Position\n\n\n\n\n\n","category":"type"},{"location":"#KM3io.jl","page":"Home","title":"KM3io.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"KM3io.jl is a Julia library which implements high-performance I/O functions and additional utilities to deal with dataformats used in KM3NeT, e.g. ROOT (online/offline files), DETX (detector geometry and calibrations) and acoustics (waveforms and hardware). In contrast to Python, you are free to utilise as many (nested) for-loops as you like while still being as fast as in e.g. in C++.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Apropos ROOT and C++, the KM3NeT Dataformat is defined in C++ and uses the I/O functionality of the ROOT framework to create the online and offline ROOT files. Luckily, there is a pure Julia library named UnROOT.jl that provides access the the ROOT files without the need to install ROOT or the corresponding C++ library. This allows KM3io.jl to be completely free from these external dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The library is still under development so that the API might slightly change. Feedback and contributions are highly welcome!","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KM3io.jl is not an officially registered Julia package but it's available via the KM3NeT Julia registry. To add the KM3NeT Julia registry to your local Julia registry list, follow the instructions in its README.","category":"page"},{"location":"#ROOT-Files","page":"Home","title":"ROOT Files","text":"","category":"section"},{"location":"#Offline-Dataformat","page":"Home","title":"Offline Dataformat","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The offline dataformat is used to store Monte Carlo (MC) simulations and reconstruction results.","category":"page"},{"location":"#Online-Dataformat","page":"Home","title":"Online Dataformat","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The online dataformat refers to the dataformat which is written by the data acquisition system (DAQ) of the KM3NeT detectors, more precisely, the ROOT files produced by the JDataFilter which is part of the Jpp framework. The very same format is used in run-by-run (RBR) Monte Carlo (MC) productions, which mimic the detector response and therefore produce similarly structured data.","category":"page"},{"location":"#Event-data","page":"Home","title":"Event data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Accessing the data is as easy as opening it via OnlineFile(\"path/to/file.root\") and using indices/slices or iteration. Everything is lazily loaded so that the data is only occupying memory when it's actually accessed. In the examples below, we use KM3NeTTestdata to get access to small sample files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using KM3io\n\njulia> using KM3NeTTestData\n\njulia> f = OnlineFile(datapath(\"online\", \"km3net_online.root\"))\nOnlineFile with 3 events\n\njulia> event = f.events[1]\nKM3io.DAQEvent with 96 snapshot and 18 triggered hits\n\njulia> event.triggered_hits[4:8]\n5-element Vector{KM3io.TriggeredHit}:\n KM3io.TriggeredHit(808447186, 0x00, 30733214, 0x19, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x01, 30733214, 0x15, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x02, 30733215, 0x15, 0x0000000000000016)\n KM3io.TriggeredHit(808447186, 0x03, 30733214, 0x1c, 0x0000000000000016)\n KM3io.TriggeredHit(808451907, 0x07, 30733441, 0x1e, 0x0000000000000004)\n\njulia> for event ∈ f.events\n           @show event.header.frame_index length(event.snapshot_hits)\n       end\nevent.header.frame_index = 127\nlength(event.snapshot_hits) = 96\nevent.header.frame_index = 127\nlength(event.snapshot_hits) = 124\nevent.header.frame_index = 129\nlength(event.snapshot_hits) = 78","category":"page"},{"location":"#Summaryslices-and-Summary-Frames","page":"Home","title":"Summaryslices and Summary Frames","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Summaryslices are generated from timeslices (raw hit data) and are produced by the DataFilter. A slice contains the data of 100ms and is divided into so-called frames, each corresponding to the data of a single optical module. Due to the high amount of data, the storage of timeslices is usually reduced by a factor of 10-100 after the event triggering stage. However, summaryslices are covering the full data taking period. They however do not contain hit data but only the rates of the PMTs encoded into a single byte, which therefore is only capable to store 256 different values. The actual rate is calcuated by a helper function (TODO).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The summaryslices are accessible using the .summaryslices attribute of the OnlineFile instance:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using KM3io, UnROOT, KM3NeTTestData\n\njulia> f = OnlineFile(datapath(\"online\", \"km3net_online.root\"))\nOnlineFile with 3 events\n\njulia> f.summaryslices\nKM3io.SummarysliceContainer with 3 summaryslices\n\njulia> for s ∈ f.summaryslices\n           @show s.header\n       end\ns.header = KM3io.SummarysliceHeader(44, 6633, 126, KM3io.UTCExtended(0x5dc6018c, 0x23c34600, false))\ns.header = KM3io.SummarysliceHeader(44, 6633, 127, KM3io.UTCExtended(0x5dc6018c, 0x29b92700, false))\ns.header = KM3io.SummarysliceHeader(44, 6633, 128, KM3io.UTCExtended(0x5dc6018c, 0x2faf0800, false))","category":"page"},{"location":"","page":"Home","title":"Home","text":"To access the actual PMT rates and flags (e.g. for high-rate veto or FIFO status), the s.frames can be used (TODO).","category":"page"}]
}
